<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Competition Jigsaw Puzzle</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .container {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-width: 1000px;
            width: 100%;
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        
        .session-info {
            background: #f0f8ff;
            border: 2px solid #4CAF50;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .session-id {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #2196F3;
            font-size: 18px;
        }
        
        .timer {
            font-size: 24px;
            font-weight: bold;
            color: #333;
            margin: 10px 0;
        }
        
        .status {
            font-size: 16px;
            margin: 5px 0;
        }
        
        .status.not-started { color: #666; }
        .status.in-progress { color: #FF9800; }
        .status.completed { color: #4CAF50; }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        input[type="file"] {
            display: none;
        }
        
        label[for="imageInput"] {
            display: inline-block;
            cursor: pointer;
        }
        
        .btn {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }
        
        .btn:hover {
            background: #45a049;
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .btn.secondary {
            background: #2196F3;
        }
        
        .btn.secondary:hover {
            background: #1976D2;
        }
        
        .btn.danger {
            background: #f44336;
        }
        
        .btn.danger:hover {
            background: #d32f2f;
        }
        
        .btn.success {
            background: #4CAF50;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        select {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-size: 14px;
        }
        
        .game-area {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .canvas-container {
            border: 2px solid #333;
            border-radius: 10px;
            background: #f9f9f9;
            position: relative;
        }
        
        canvas {
            display: block;
            border-radius: 8px;
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .highlight-target {
            animation: highlightPulse 1s ease-in-out infinite;
        }
        
        @keyframes highlightPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }
        
        body.dragging {
            cursor: grabbing !important;
        }
        
        body.dragging * {
            cursor: grabbing !important;
        }
        
        .info {
            text-align: center;
            margin-top: 10px;
            color: #666;
        }
        
        .completion-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .completion-time {
            font-size: 32px;
            font-weight: bold;
            color: #4CAF50;
            margin: 20px 0;
        }
        
        .results-code {
            background: #f5f5f5;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Courier New', monospace;
            word-break: break-all;
            margin: 20px 0;
            font-size: 14px;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #45a049);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            background: #f9f9f9;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #333;
        }
        
        .stat-label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèÜ Competition Jigsaw Puzzle</h1>
        
        <div class="session-info">
            <div>Session ID: <span class="session-id" id="sessionId"></span></div>
            <div class="timer" id="timer">00:00:00</div>
            <div class="status not-started" id="status">Ready to start - Move your first piece to begin!</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="piecesPlaced">0</div>
                <div class="stat-label">Pieces Placed</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="totalPieces">64</div>
                <div class="stat-label">Total Pieces</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="accuracy">0%</div>
                <div class="stat-label">Accuracy</div>
            </div>
        </div>
        
        <div class="controls">
            <button class="btn secondary" onclick="resetPuzzle()">
                üîÑ Reset Puzzle
            </button>
            <button class="btn danger" onclick="clearProgress()">
                üóëÔ∏è Clear All Progress
            </button>
        </div>
        
        <div class="game-area">
            <div class="canvas-container">
                <canvas id="puzzleCanvas" width="400" height="400"></canvas>
                <div class="info">Puzzle Board - Drop pieces here!</div>
            </div>
            <div class="canvas-container">
                <canvas id="piecesCanvas" width="400" height="400"></canvas>
                <div class="info">Puzzle Pieces - Drag to solve!</div>
            </div>
        </div>
    </div>
    
    <div class="completion-modal" id="completionModal">
        <div class="modal-content">
            <h2>üéâ Puzzle Completed! üéâ</h2>
            <div class="completion-time" id="finalTime"></div>
            <p>Congratulations! You've successfully completed the puzzle.</p>
            
            <div id="userInfoForm" style="margin: 20px 0;">
                <h3>Save Your Score!</h3>
                <p>Enter your details to save this completion to the leaderboard:</p>
                <div style="margin: 10px 0;">
                    <input type="text" id="userName" placeholder="Your Name" style="width: 100%; padding: 10px; margin: 5px 0; border: 1px solid #ddd; border-radius: 5px;">
                </div>
                <div style="margin: 10px 0;">
                    <input type="email" id="userEmail" placeholder="Your Email" style="width: 100%; padding: 10px; margin: 5px 0; border: 1px solid #ddd; border-radius: 5px;">
                </div>
                <button class="btn success" onclick="saveScore()" id="saveScoreBtn">üíæ Save Score</button>
                <button class="btn secondary" onclick="skipSaving()" style="margin-left: 10px;">Skip</button>
            </div>
            
            <div id="resultsSection" style="display: none;">
                <h3>Your Results:</h3>
                <div class="results-code" id="resultsCode"></div>
                
                <div style="margin: 20px 0;">
                    <button class="btn success" onclick="copyResults()">üìã Copy Results</button>
                    <button class="btn secondary" onclick="downloadScreenshot()">üì∑ Download Screenshot</button>
                    <button class="btn" onclick="shareResults()">üì§ Share Results</button>
                </div>
                
                <button class="btn secondary" onclick="closeModal()">Close</button>
            </div>
        </div>
    </div>

    <script>
        class CompetitionJigsawPuzzle {
            constructor() {
                this.puzzleCanvas = document.getElementById('puzzleCanvas');
                this.piecesCanvas = document.getElementById('piecesCanvas');
                this.puzzleCtx = this.puzzleCanvas.getContext('2d');
                this.piecesCtx = this.piecesCanvas.getContext('2d');
                
                this.sessionId = this.generateSessionId();
                this.image = null;
                this.pieces = [];
                this.gridSize = 8;
                this.pieceWidth = 0;
                this.pieceHeight = 0;
                this.draggedPiece = null;
                this.dragOffset = { x: 0, y: 0 };
                this.dragSource = null;
                this.originalPosition = null;
                
                // Timer and progress tracking
                this.startTime = null;
                this.endTime = null;
                this.timerInterval = null;
                this.gameStarted = false;
                this.gameCompleted = false;
                this.moveCount = 0;
                this.correctMoves = 0;
                
                this.initializeSession();
                this.initEventListeners();
                this.loadFromStorage();
            }
            
            generateSessionId() {
                const timestamp = Date.now().toString(36);
                const random = Math.random().toString(36).substr(2, 5);
                return `PUZZLE-${timestamp}-${random}`.toUpperCase();
            }
            
            initializeSession() {
                document.getElementById('sessionId').textContent = this.sessionId;
                this.updateDisplay();
            }
            
            initEventListeners() {
                // Remove difficulty selector event listener since we removed the element
                // this.gridSize is fixed at 8 for competition
                
                // Mouse events on both canvases
                this.piecesCanvas.addEventListener('mousedown', (e) => this.onMouseDown(e, 'pieces'));
                this.puzzleCanvas.addEventListener('mousedown', (e) => this.onMouseDown(e, 'puzzle'));
                
                // Global mouse events for dragging
                document.addEventListener('mousemove', (e) => this.onMouseMove(e));
                document.addEventListener('mouseup', (e) => this.onMouseUp(e));
                
                // Touch events on both canvases
                this.piecesCanvas.addEventListener('touchstart', (e) => this.onTouchStart(e, 'pieces'));
                this.puzzleCanvas.addEventListener('touchstart', (e) => this.onTouchStart(e, 'puzzle'));
                
                // Global touch events for dragging
                document.addEventListener('touchmove', (e) => this.onTouchMove(e));
                document.addEventListener('touchend', (e) => this.onTouchEnd(e));
                
                // Auto-save every 5 seconds
                setInterval(() => this.saveToStorage(), 5000);
            }
            
            saveToStorage() {
                if (!this.pieces.length) return;
                
                const gameState = {
                    sessionId: this.sessionId,
                    gridSize: this.gridSize,
                    pieces: this.pieces.map(p => ({
                        id: p.id,
                        correctRow: p.correctRow,
                        correctCol: p.correctCol,
                        currentRow: p.currentRow,
                        currentCol: p.currentCol,
                        x: p.x,
                        y: p.y,
                        placed: p.placed
                    })),
                    gameStarted: this.gameStarted,
                    gameCompleted: this.gameCompleted,
                    startTime: this.startTime,
                    endTime: this.endTime,
                    moveCount: this.moveCount,
                    correctMoves: this.correctMoves,
                    imageData: this.image ? this.image.src : null
                };
                
                localStorage.setItem('puzzleGameState', JSON.stringify(gameState));
            }
            
            loadFromStorage() {
                const saved = localStorage.getItem('puzzleGameState');
                if (!saved) {
                    this.loadDefaultImage();
                    return;
                }
                
                try {
                    const gameState = JSON.parse(saved);
                    
                    // Restore basic state
                    this.gridSize = gameState.gridSize;
                    this.gameStarted = gameState.gameStarted;
                    this.gameCompleted = gameState.gameCompleted;
                    this.startTime = gameState.startTime;
                    this.endTime = gameState.endTime;
                    this.moveCount = gameState.moveCount || 0;
                    this.correctMoves = gameState.correctMoves || 0;
                    
                    // Difficulty is fixed at 8 for competition
                    
                    // Restore image and pieces
                    if (gameState.imageData && gameState.pieces && gameState.pieces.length > 0) {
                        this.image = new Image();
                        this.image.onload = () => {
                            this.pieceWidth = 400 / this.gridSize;
                            this.pieceHeight = 400 / this.gridSize;
                            this.pieces = gameState.pieces;
                            this.render();
                            this.updateDisplay();
                            
                            if (this.gameStarted && !this.gameCompleted) {
                                this.startTimer();
                            }
                        };
                        this.image.onerror = () => {
                            console.error('Failed to restore saved image, loading default');
                            this.loadDefaultImage();
                        };
                        this.image.src = gameState.imageData;
                    } else {
                        this.loadDefaultImage();
                    }
                    
                } catch (e) {
                    console.error('Failed to load saved game:', e);
                    this.loadDefaultImage();
                }
            }
            
            loadDefaultImage() {
                console.log('üñºÔ∏è Loading default image...');
                this.image = new Image();
                this.image.onload = () => {
                    console.log('‚úÖ Successfully loaded smarty.jpg');
                    console.log('Image dimensions:', this.image.width, 'x', this.image.height);
                    this.createPuzzle();
                };
                this.image.onerror = (e) => {
                    console.error('‚ùå Failed to load smarty.jpg:', e);
                    console.log('üé® Creating fallback image...');
                    this.createFallbackImage();
                };
                
                // Try to load smarty.jpg from the same directory
                console.log('üìÇ Attempting to load: smarty.jpg');
                this.image.src = 'smarty.jpg';
            }
            
            createFallbackImage() {
                // Create a simple colored pattern as fallback
                const canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 400;
                const ctx = canvas.getContext('2d');
                
                // Create a colorful pattern
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const hue = (i * 8 + j) * 45;
                        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                        ctx.fillRect(i * 50, j * 50, 50, 50);
                        
                        // Add some text
                        ctx.fillStyle = 'white';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${i * 8 + j + 1}`, i * 50 + 25, j * 50 + 30);
                    }
                }
                
                this.image = new Image();
                this.image.onload = () => this.createPuzzle();
                this.image.src = canvas.toDataURL();
            }
            
            loadImage(file) {
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.image = new Image();
                    this.image.onload = () => this.createPuzzle();
                    this.image.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            createPuzzle() {
                this.resetGame();
                this.pieces = [];
                this.pieceWidth = 400 / this.gridSize;
                this.pieceHeight = 400 / this.gridSize;
                
                console.log(`Creating ${this.gridSize}x${this.gridSize} puzzle with ${this.pieceWidth}x${this.pieceHeight}px pieces`);
                
                // Create pieces
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const piece = {
                            id: row * this.gridSize + col,
                            correctRow: row,
                            correctCol: col,
                            currentRow: -1,
                            currentCol: -1,
                            x: 0,
                            y: 0,
                            placed: false
                        };
                        this.pieces.push(piece);
                    }
                }
                
                console.log(`Created ${this.pieces.length} pieces total`);
                console.log(`Expected: ${this.gridSize * this.gridSize} pieces`);
                console.log(`First piece:`, this.pieces[0]);
                console.log(`Last piece:`, this.pieces[this.pieces.length - 1]);
                
                this.shufflePieces();
                this.updateDisplay();
                this.render();
            }
            
            shufflePieces() {
                if (!this.pieces.length) return;
                
                console.log(`Shuffling ${this.pieces.length} pieces in ${this.gridSize}x${this.gridSize} grid`);
                
                // Reset all pieces
                this.pieces.forEach(piece => {
                    piece.placed = false;
                    piece.currentRow = -1;
                    piece.currentCol = -1;
                });
                
                // Position pieces in exact 8x8 grid layout to match puzzle canvas
                this.pieces.forEach((piece, index) => {
                    const row = Math.floor(index / this.gridSize);
                    const col = index % this.gridSize;
                    // Use exact same positioning as puzzle grid - no margins between pieces
                    piece.x = col * this.pieceWidth;
                    piece.y = row * this.pieceHeight;
                    
                    // Debug: check if pieces are positioned outside canvas
                    if (piece.x + this.pieceWidth > 400 || piece.y + this.pieceHeight > 400) {
                        console.warn(`Piece ${piece.id} positioned outside canvas: (${piece.x}, ${piece.y})`);
                    }
                });
                
                console.log(`Positioned pieces in ${this.gridSize}x${this.gridSize} grid, piece size: ${this.pieceWidth}x${this.pieceHeight}`);
                console.log(`Sample positions:`, this.pieces.slice(0, 3).map(p => `(${p.x}, ${p.y})`));
                
                // Shuffle array to randomize piece order
                for (let i = this.pieces.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [this.pieces[i], this.pieces[j]] = [this.pieces[j], this.pieces[i]];
                }
                
                // Create a shuffled array of all 64 positions
                const allPositions = [];
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        allPositions.push({ row, col });
                    }
                }
                
                // Shuffle the positions array
                for (let i = allPositions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allPositions[i], allPositions[j]] = [allPositions[j], allPositions[i]];
                }
                
                // Assign each piece a unique random position
                this.pieces.forEach((piece, index) => {
                    const position = allPositions[index];
                    piece.x = position.col * this.pieceWidth;
                    piece.y = position.row * this.pieceHeight;
                });
                
                console.log(`Positioned all ${this.pieces.length} pieces in randomized grid locations`);
                
                this.render();
            }
            
            startTimer() {
                if (this.timerInterval) return;
                
                this.timerInterval = setInterval(() => {
                    this.updateTimer();
                }, 1000);
            }
            
            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }
            
            updateTimer() {
                if (!this.startTime) return;
                
                const now = this.gameCompleted ? this.endTime : Date.now();
                const elapsed = Math.floor((now - this.startTime) / 1000);
                
                const hours = Math.floor(elapsed / 3600);
                const minutes = Math.floor((elapsed % 3600) / 60);
                const seconds = elapsed % 60;
                
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('timer').textContent = timeString;
            }
            
            updateDisplay() {
                const placedPieces = this.pieces.filter(p => p.placed).length;
                const totalPieces = this.pieces.length;
                const progress = totalPieces > 0 ? (placedPieces / totalPieces) * 100 : 0;
                const accuracy = this.moveCount > 0 ? Math.round((this.correctMoves / this.moveCount) * 100) : 0;
                
                document.getElementById('piecesPlaced').textContent = placedPieces;
                document.getElementById('totalPieces').textContent = totalPieces;
                document.getElementById('accuracy').textContent = accuracy + '%';
                document.getElementById('progressFill').style.width = progress + '%';
                
                // Update status
                const statusEl = document.getElementById('status');
                if (this.gameCompleted) {
                    statusEl.textContent = 'Puzzle completed! üéâ';
                    statusEl.className = 'status completed';
                } else if (this.gameStarted) {
                    statusEl.textContent = `In progress - ${placedPieces}/${totalPieces} pieces placed`;
                    statusEl.className = 'status in-progress';
                } else {
                    statusEl.textContent = 'Ready to start - Move your first piece to begin!';
                    statusEl.className = 'status not-started';
                }
            }
            
            render() {
                // Clear both canvases
                this.puzzleCtx.clearRect(0, 0, 400, 400);
                this.piecesCtx.clearRect(0, 0, 400, 400);
                
                // Draw grid on both canvases for visual consistency
                [this.puzzleCtx, this.piecesCtx].forEach(ctx => {
                    ctx.strokeStyle = '#ddd';
                    ctx.lineWidth = 1;
                    for (let i = 0; i <= this.gridSize; i++) {
                        const pos = i * this.pieceWidth;
                        ctx.beginPath();
                        ctx.moveTo(pos, 0);
                        ctx.lineTo(pos, 400);
                        ctx.stroke();
                        
                        ctx.beginPath();
                        ctx.moveTo(0, pos);
                        ctx.lineTo(400, pos);
                        ctx.stroke();
                    }
                });
                
                // Show drop zone highlight when dragging
                if (this.draggedPiece && this.draggedPiece.globalX && this.draggedPiece.globalY) {
                    const puzzleRect = this.puzzleCanvas.getBoundingClientRect();
                    
                    // Check if mouse is over puzzle canvas
                    if (this.draggedPiece.globalX >= puzzleRect.left - 30 && 
                        this.draggedPiece.globalX <= puzzleRect.right + 30 &&
                        this.draggedPiece.globalY >= puzzleRect.top - 30 && 
                        this.draggedPiece.globalY <= puzzleRect.bottom + 30) {
                        
                        // Calculate target grid position
                        const x = Math.max(0, Math.min(this.draggedPiece.globalX - puzzleRect.left, 400));
                        const y = Math.max(0, Math.min(this.draggedPiece.globalY - puzzleRect.top, 400));
                        
                        // Use floor with offset for consistent positioning with drop logic
                        let col = Math.floor((x + this.pieceWidth * 0.5) / this.pieceWidth);
                        let row = Math.floor((y + this.pieceHeight * 0.5) / this.pieceHeight);
                        
                        // Ensure within bounds
                        col = Math.max(0, Math.min(col, this.gridSize - 1));
                        row = Math.max(0, Math.min(row, this.gridSize - 1));
                        
                        // Check if position is occupied
                        const occupiedPiece = this.pieces.find(p => 
                            p.placed && p.currentRow === row && p.currentCol === col && p !== this.draggedPiece);
                        
                        // Draw drop zone highlight
                        this.puzzleCtx.save();
                        if (occupiedPiece) {
                            // Occupied - show swap preview
                            this.puzzleCtx.fillStyle = 'rgba(255, 152, 0, 0.4)';
                            this.puzzleCtx.strokeStyle = '#FF9800';
                        } else {
                            // Available - show green highlight  
                            this.puzzleCtx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                            this.puzzleCtx.strokeStyle = '#4CAF50';
                        }
                        this.puzzleCtx.lineWidth = 3;
                        const highlightX = col * this.pieceWidth;
                        const highlightY = row * this.pieceHeight;
                        this.puzzleCtx.fillRect(highlightX, highlightY, this.pieceWidth, this.pieceHeight);
                        this.puzzleCtx.strokeRect(highlightX, highlightY, this.pieceWidth, this.pieceHeight);
                        this.puzzleCtx.restore();
                    }
                }
                
                // Draw pieces (except the currently dragged one)
                let placedCount = 0;
                let unplacedCount = 0;
                
                this.pieces.forEach(piece => {
                    if (piece === this.draggedPiece) return; // Skip dragged piece for now
                    
                    if (piece.placed) {
                        placedCount++;
                        this.drawPiece(this.puzzleCtx, piece, 
                            piece.currentCol * this.pieceWidth, 
                            piece.currentRow * this.pieceHeight);
                    } else {
                        unplacedCount++;
                        this.drawPiece(this.piecesCtx, piece, piece.x, piece.y);
                    }
                });
                
                // Debug: log piece counts occasionally
                if (Math.random() < 0.1) { // 10% of renders
                    console.log(`Rendering: ${placedCount} placed, ${unplacedCount} unplaced, total: ${this.pieces.length}`);
                }
                
                // Draw the dragged piece on both canvases to ensure visibility everywhere
                if (this.draggedPiece && this.draggedPiece.globalX && this.draggedPiece.globalY) {
                    const pieceRect = this.piecesCanvas.getBoundingClientRect();
                    const puzzleRect = this.puzzleCanvas.getBoundingClientRect();
                    
                    // Always draw on pieces canvas
                    this.drawPiece(this.piecesCtx, this.draggedPiece, 
                        this.draggedPiece.x, this.draggedPiece.y);
                    
                    // If mouse is over puzzle canvas, also draw there
                    if (this.draggedPiece.globalX >= puzzleRect.left && 
                        this.draggedPiece.globalX <= puzzleRect.right &&
                        this.draggedPiece.globalY >= puzzleRect.top && 
                        this.draggedPiece.globalY <= puzzleRect.bottom) {
                        
                        const puzzleX = this.draggedPiece.globalX - puzzleRect.left - this.dragOffset.x;
                        const puzzleY = this.draggedPiece.globalY - puzzleRect.top - this.dragOffset.y;
                        this.drawPiece(this.puzzleCtx, this.draggedPiece, puzzleX, puzzleY);
                    }
                } else if (this.draggedPiece) {
                    // Fallback: just draw on pieces canvas
                    this.drawPiece(this.piecesCtx, this.draggedPiece, 
                        this.draggedPiece.x, this.draggedPiece.y);
                }
            }
            
            drawPiece(ctx, piece, x, y) {
                if (!this.image) {
                    console.warn('No image loaded for drawing pieces');
                    return;
                }
                
                ctx.save();
                
                // Enhanced shadow and scaling for dragged pieces
                const isDragged = piece === this.draggedPiece;
                
                if (isDragged) {
                    // Stronger shadow for dragged piece
                    ctx.shadowColor = 'rgba(0,0,0,0.6)';
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetX = 5;
                    ctx.shadowOffsetY = 5;
                    
                    // Slight scale up for dragged piece
                    const scale = 1.05;
                    const scaledWidth = this.pieceWidth * scale;
                    const scaledHeight = this.pieceHeight * scale;
                    const offsetX = (scaledWidth - this.pieceWidth) / 2;
                    const offsetY = (scaledHeight - this.pieceHeight) / 2;
                    
                    // Draw scaled piece
                    ctx.drawImage(
                        this.image,
                        piece.correctCol * this.pieceWidth, piece.correctRow * this.pieceHeight,
                        this.pieceWidth, this.pieceHeight,
                        x - offsetX, y - offsetY,
                        scaledWidth, scaledHeight
                    );
                    
                    // Draw border for dragged piece
                    ctx.shadowColor = 'transparent';
                    ctx.strokeStyle = '#2196F3'; // Blue border for dragged pieces
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x - offsetX, y - offsetY, scaledWidth, scaledHeight);
                } else {
                    // Normal shadow for non-dragged pieces
                    ctx.shadowColor = 'rgba(0,0,0,0.3)';
                    ctx.shadowBlur = 5;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    
                    // Draw the piece image normally
                    ctx.drawImage(
                        this.image,
                        piece.correctCol * this.pieceWidth, piece.correctRow * this.pieceHeight,
                        this.pieceWidth, this.pieceHeight,
                        x, y,
                        this.pieceWidth, this.pieceHeight
                    );
                    
                    // Draw border
                    ctx.shadowColor = 'transparent';
                    ctx.strokeStyle = piece.placed && 
                        piece.currentRow === piece.correctRow && 
                        piece.currentCol === piece.correctCol ? '#4CAF50' : '#333';
                    ctx.lineWidth = piece.placed && 
                        piece.currentRow === piece.correctRow && 
                        piece.currentCol === piece.correctCol ? 3 : 2;
                    ctx.strokeRect(x, y, this.pieceWidth, this.pieceHeight);
                }
                
                ctx.restore();
            }
            
            getMousePos(canvas, e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            getTouchPos(canvas, e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
            }
            
            findPieceAt(x, y) {
                for (let i = this.pieces.length - 1; i >= 0; i--) {
                    const piece = this.pieces[i];
                    if (!piece.placed &&
                        x >= piece.x && x <= piece.x + this.pieceWidth &&
                        y >= piece.y && y <= piece.y + this.pieceHeight) {
                        return piece;
                    }
                }
                return null;
            }
            
            findPieceOnGrid(x, y) {
                const col = Math.floor(x / this.pieceWidth);
                const row = Math.floor(y / this.pieceHeight);
                
                if (row >= 0 && row < this.gridSize && col >= 0 && col < this.gridSize) {
                    return this.pieces.find(piece => 
                        piece.placed && piece.currentRow === row && piece.currentCol === col);
                }
                return null;
            }
            
            snapBackToOriginal() {
                if (!this.draggedPiece || !this.originalPosition) return;
                
                // Store references to prevent null errors during animation
                const piece = this.draggedPiece;
                const originalPos = this.originalPosition;
                
                // Animate snap-back for better user feedback
                const startX = piece.x;
                const startY = piece.y;
                const targetX = originalPos.x;
                const targetY = originalPos.y;
                
                const duration = 300; // Animation duration in ms
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    
                    // Easing function for smooth animation
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    
                    // Interpolate position - check piece still exists
                    if (piece) {
                        piece.x = startX + (targetX - startX) * easeOut;
                        piece.y = startY + (targetY - startY) * easeOut;
                    }
                    
                    this.render();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        // Animation complete - restore full state
                        if (piece && originalPos) {
                            piece.placed = originalPos.placed;
                            piece.currentRow = originalPos.currentRow;
                            piece.currentCol = originalPos.currentCol;
                        }
                        
                        // Clear drag state now that animation is complete
                        this.draggedPiece = null;
                        this.dragSource = null;
                        this.originalPosition = null;
                        document.body.classList.remove('dragging');
                        
                        this.render();
                        this.updateDisplay();
                        this.saveToStorage();
                    }
                };
                
                console.log(`‚¨ÖÔ∏è Snapping piece ${piece.id} back to original position`);
                requestAnimationFrame(animate);
            }
            
            onMouseDown(e, canvasType) {
                if (canvasType === 'pieces') {
                    // Handle pieces canvas - find unplaced pieces
                    const pos = this.getMousePos(this.piecesCanvas, e);
                    console.log(`Mouse down on pieces canvas at (${pos.x}, ${pos.y})`);
                    this.draggedPiece = this.findPieceAt(pos.x, pos.y);
                    
                    if (this.draggedPiece) {
                        this.dragOffset.x = pos.x - this.draggedPiece.x;
                        this.dragOffset.y = pos.y - this.draggedPiece.y;
                        this.dragSource = 'pieces';
                        // Store original position for snap-back
                        this.originalPosition = {
                            x: this.draggedPiece.x,
                            y: this.draggedPiece.y,
                            placed: false,
                            currentRow: -1,
                            currentCol: -1
                        };
                        document.body.classList.add('dragging');
                        console.log('Started dragging piece from pieces canvas', this.draggedPiece.id);
                    } else {
                        console.log('No piece found at mouse position');
                        // Debug: show all unplaced pieces and their positions
                        const unplacedPieces = this.pieces.filter(p => !p.placed);
                        console.log(`Unplaced pieces (${unplacedPieces.length}):`, 
                            unplacedPieces.slice(0, 5).map(p => `Piece ${p.id}: (${p.x}, ${p.y})`));
                    }
                } else if (canvasType === 'puzzle') {
                    // Handle puzzle canvas - find placed pieces
                    const pos = this.getMousePos(this.puzzleCanvas, e);
                    this.draggedPiece = this.findPieceOnGrid(pos.x, pos.y);
                    
                    if (this.draggedPiece) {
                        // Store original grid position for snap-back
                        this.originalPosition = {
                            x: this.draggedPiece.currentCol * this.pieceWidth,
                            y: this.draggedPiece.currentRow * this.pieceHeight,
                            placed: true,
                            currentRow: this.draggedPiece.currentRow,
                            currentCol: this.draggedPiece.currentCol
                        };
                        
                        // Remove from grid and move to pieces canvas coordinates
                        this.draggedPiece.placed = false;
                        this.draggedPiece.currentRow = -1;
                        this.draggedPiece.currentCol = -1;
                        
                        // Calculate initial position on pieces canvas
                        this.draggedPiece.x = pos.x;
                        this.draggedPiece.y = pos.y;
                        
                        this.dragOffset.x = 0;
                        this.dragOffset.y = 0;
                        this.dragSource = 'puzzle';
                        document.body.classList.add('dragging');
                        console.log('Started dragging piece from puzzle grid', this.draggedPiece.id);
                        
                        // Re-render to show piece removed from grid
                        this.render();
                        this.updateDisplay();
                    }
                }
            }
            
            onMouseMove(e) {
                if (this.draggedPiece) {
                    // Store global mouse position for drop zone highlighting
                    this.draggedPiece.globalX = e.clientX;
                    this.draggedPiece.globalY = e.clientY;
                    
                    // Calculate position relative to pieces canvas for rendering
                    const rect = this.piecesCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    this.draggedPiece.x = x - this.dragOffset.x;
                    this.draggedPiece.y = y - this.dragOffset.y;
                    this.render();
                }
            }
            
            onMouseUp(e) {
                if (this.draggedPiece) {
                    console.log('Mouse up - checking drop for piece', this.draggedPiece.id);
                    this.checkDrop(e);
                    
                    // Clear drag state
                    console.log('Clearing drag state');
                    this.draggedPiece = null;
                    this.dragSource = null;
                    this.originalPosition = null;
                    document.body.classList.remove('dragging');
                    
                    // Force a re-render to ensure UI is updated
                    this.render();
                }
            }
            
            onTouchStart(e, canvasType) {
                e.preventDefault();
                
                if (canvasType === 'pieces') {
                    // Handle pieces canvas - find unplaced pieces
                    const pos = this.getTouchPos(this.piecesCanvas, e);
                    this.draggedPiece = this.findPieceAt(pos.x, pos.y);
                    
                    if (this.draggedPiece) {
                        this.dragOffset.x = pos.x - this.draggedPiece.x;
                        this.dragOffset.y = pos.y - this.draggedPiece.y;
                        this.dragSource = 'pieces';
                        // Store original position for snap-back
                        this.originalPosition = {
                            x: this.draggedPiece.x,
                            y: this.draggedPiece.y,
                            placed: false,
                            currentRow: -1,
                            currentCol: -1
                        };
                        document.body.classList.add('dragging');
                        console.log('Started touch dragging piece from pieces canvas', this.draggedPiece.id);
                    }
                } else if (canvasType === 'puzzle') {
                    // Handle puzzle canvas - find placed pieces
                    const pos = this.getTouchPos(this.puzzleCanvas, e);
                    this.draggedPiece = this.findPieceOnGrid(pos.x, pos.y);
                    
                    if (this.draggedPiece) {
                        // Store original grid position for snap-back
                        this.originalPosition = {
                            x: this.draggedPiece.currentCol * this.pieceWidth,
                            y: this.draggedPiece.currentRow * this.pieceHeight,
                            placed: true,
                            currentRow: this.draggedPiece.currentRow,
                            currentCol: this.draggedPiece.currentCol
                        };
                        
                        // Remove from grid and move to pieces canvas coordinates
                        this.draggedPiece.placed = false;
                        this.draggedPiece.currentRow = -1;
                        this.draggedPiece.currentCol = -1;
                        
                        // Calculate initial position on pieces canvas
                        this.draggedPiece.x = pos.x;
                        this.draggedPiece.y = pos.y;
                        
                        this.dragOffset.x = 0;
                        this.dragOffset.y = 0;
                        this.dragSource = 'puzzle';
                        document.body.classList.add('dragging');
                        console.log('Started touch dragging piece from puzzle grid', this.draggedPiece.id);
                        
                        // Re-render to show piece removed from grid
                        this.render();
                        this.updateDisplay();
                    }
                }
            }
            
            onTouchMove(e) {
                e.preventDefault();
                if (this.draggedPiece) {
                    // Calculate position relative to pieces canvas
                    const rect = this.piecesCanvas.getBoundingClientRect();
                    const x = e.touches[0].clientX - rect.left;
                    const y = e.touches[0].clientY - rect.top;
                    
                    this.draggedPiece.x = x - this.dragOffset.x;
                    this.draggedPiece.y = y - this.dragOffset.y;
                    this.render();
                }
            }
            
            onTouchEnd(e) {
                e.preventDefault();
                if (this.draggedPiece) {
                    console.log('Touch end - checking drop');
                    this.checkDrop(e);
                    this.draggedPiece = null;
                    this.dragSource = null;
                    this.originalPosition = null;
                    document.body.classList.remove('dragging');
                }
            }
            
            checkDrop(e) {
                if (!this.draggedPiece) return;
                
                // Start game if not started
                if (!this.gameStarted) {
                    this.gameStarted = true;
                    this.startTime = Date.now();
                    this.startTimer();
                }
                
                this.moveCount++;
                
                // Get drop coordinates
                let clientX, clientY;
                if (e.type.includes('touch')) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                // Check if dropped on puzzle canvas (with tolerance)
                const puzzleRect = this.puzzleCanvas.getBoundingClientRect();
                const tolerance = 30; // Generous drop zone
                
                if (clientX >= puzzleRect.left - tolerance && clientX <= puzzleRect.right + tolerance &&
                    clientY >= puzzleRect.top - tolerance && clientY <= puzzleRect.bottom + tolerance) {
                    
                    // Smart grid snapping - find nearest valid position
                    const x = Math.max(0, Math.min(clientX - puzzleRect.left, 400));
                    const y = Math.max(0, Math.min(clientY - puzzleRect.top, 400));
                    
                    // Use floor with offset for more predictable positioning
                    let col = Math.floor((x + this.pieceWidth * 0.5) / this.pieceWidth);
                    let row = Math.floor((y + this.pieceHeight * 0.5) / this.pieceHeight);
                    
                    // Ensure within grid bounds
                    col = Math.max(0, Math.min(col, this.gridSize - 1));
                    row = Math.max(0, Math.min(row, this.gridSize - 1));
                    
                    // Check what's at this position
                    const occupiedPiece = this.pieces.find(p => 
                        p.placed && p.currentRow === row && p.currentCol === col && p !== this.draggedPiece);
                    
                    if (!occupiedPiece) {
                        // Position is free - place piece with smooth animation
                        this.placePieceAt(this.draggedPiece, row, col);
                    } else {
                        // Position occupied - swap the pieces
                        this.swapPieces(this.draggedPiece, occupiedPiece, row, col);
                    }
                } else {
                    // Dropped outside - return to original position
                    this.snapBackToOriginal();
                    return;
                }
            }
            
            placePieceAt(piece, row, col) {
                piece.placed = true;
                piece.currentRow = row;
                piece.currentCol = col;
                
                // Check if correct placement
                if (row === piece.correctRow && col === piece.correctCol) {
                    this.correctMoves++;
                }
                
                // Smooth animation to final position
                this.animateToPosition(piece, col * this.pieceWidth, row * this.pieceHeight);
                
                this.updateDisplay();
                this.checkWin();
                this.saveToStorage();
            }
            
            swapPieces(draggedPiece, occupiedPiece, newRow, newCol) {
                // Store occupied piece's position
                const occupiedRow = occupiedPiece.currentRow;
                const occupiedCol = occupiedPiece.currentCol;
                
                // Move occupied piece to dragged piece's original position
                if (this.originalPosition && this.originalPosition.placed) {
                    // Move to original grid position
                    occupiedPiece.currentRow = this.originalPosition.currentRow;
                    occupiedPiece.currentCol = this.originalPosition.currentCol;
                    occupiedPiece.placed = true;
                } else {
                    // Move back to pieces area
                    occupiedPiece.placed = false;
                    occupiedPiece.currentRow = -1;
                    occupiedPiece.currentCol = -1;
                    occupiedPiece.x = this.originalPosition ? this.originalPosition.x : 0;
                    occupiedPiece.y = this.originalPosition ? this.originalPosition.y : 0;
                }
                
                // Place dragged piece in new position
                this.placePieceAt(draggedPiece, newRow, newCol);
            }
            
            animateToPosition(piece, targetX, targetY) {
                const startX = piece.x || targetX;
                const startY = piece.y || targetY;
                const duration = 200;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    
                    if (piece.placed) {
                        // For placed pieces, we don't need to animate x,y (they're positioned by grid)
                        piece.x = targetX;
                        piece.y = targetY;
                    } else {
                        piece.x = startX + (targetX - startX) * easeOut;
                        piece.y = startY + (targetY - startY) * easeOut;
                    }
                    
                    this.render();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                
                requestAnimationFrame(animate);
            }
            
            checkWin() {
                const allPlaced = this.pieces.every(piece => piece.placed);
                const allCorrect = this.pieces.every(piece => 
                    piece.currentRow === piece.correctRow && 
                    piece.currentCol === piece.correctCol);
                
                if (allPlaced && allCorrect && !this.gameCompleted) {
                    this.gameCompleted = true;
                    this.endTime = Date.now();
                    this.stopTimer();
                    this.updateDisplay();
                    this.showCompletionModal();
                    this.saveToStorage();
                }
            }
            
            showCompletionModal() {
                const totalTime = this.endTime - this.startTime;
                const hours = Math.floor(totalTime / (1000 * 60 * 60));
                const minutes = Math.floor((totalTime % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((totalTime % (1000 * 60)) / 1000);
                
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                document.getElementById('finalTime').textContent = timeString;
                
                // Generate results code
                const resultsCode = this.generateResultsCode(totalTime);
                document.getElementById('resultsCode').textContent = resultsCode;
                
                document.getElementById('completionModal').style.display = 'flex';
            }
            
            generateResultsCode(totalTime) {
                const accuracy = this.moveCount > 0 ? Math.round((this.correctMoves / this.moveCount) * 100) : 0;
                const difficulty = this.gridSize;
                const timeInSeconds = Math.floor(totalTime / 1000);
                
                return `PUZZLE-RESULT:${this.sessionId}:TIME:${timeInSeconds}s:GRID:${difficulty}x${difficulty}:MOVES:${this.moveCount}:ACCURACY:${accuracy}%:COMPLETED:${new Date().toISOString()}`;
            }
            
            resetGame() {
                this.gameStarted = false;
                this.gameCompleted = false;
                this.startTime = null;
                this.endTime = null;
                this.moveCount = 0;
                this.correctMoves = 0;
                this.stopTimer();
                document.getElementById('timer').textContent = '00:00:00';
            }
            
            captureScreenshot() {
                const canvas = document.createElement('canvas');
                canvas.width = 800;
                canvas.height = 500;
                const ctx = canvas.getContext('2d');
                
                // White background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 800, 500);
                
                // Draw completed puzzle
                ctx.drawImage(this.puzzleCanvas, 50, 50);
                
                // Add completion info
                ctx.fillStyle = '#333';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('Puzzle Completed!', 500, 100);
                
                ctx.font = '18px Arial';
                const totalTime = this.endTime - this.startTime;
                const hours = Math.floor(totalTime / (1000 * 60 * 60));
                const minutes = Math.floor((totalTime % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((totalTime % (1000 * 60)) / 1000);
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                ctx.fillText(`Time: ${timeString}`, 500, 140);
                ctx.fillText(`Difficulty: ${this.gridSize}x${this.gridSize}`, 500, 170);
                ctx.fillText(`Session: ${this.sessionId}`, 500, 200);
                ctx.fillText(`Accuracy: ${Math.round((this.correctMoves / this.moveCount) * 100)}%`, 500, 230);
                
                return canvas.toDataURL('image/png');
            }
        }
        
        // Global puzzle instance
        let puzzle;
        
        function init() {
            puzzle = new CompetitionJigsawPuzzle();
        }
        
        function loadImageFile(file) {
            if (puzzle && file) {
                puzzle.loadImage(file);
            }
        }
        
        function useDefaultImage() {
            if (puzzle) {
                // Clear any existing game state to force loading fresh
                puzzle.resetGame();
                puzzle.loadDefaultImage();
            }
        }
        
        function resetPuzzle() {
            if (puzzle) {
                puzzle.shufflePieces();
                puzzle.resetGame();
                puzzle.updateDisplay();
            }
        }
        
        function clearProgress() {
            if (confirm('Are you sure you want to clear all progress? This cannot be undone.')) {
                localStorage.removeItem('puzzleGameState');
                if (puzzle) {
                    puzzle.loadDefaultImage();
                }
            }
        }
        
        function autoSolve() {
            if (!puzzle) return;
            
            console.log('üß© Auto-solving puzzle for testing...');
            
            // Start the game if not started
            if (!puzzle.gameStarted) {
                puzzle.gameStarted = true;
                puzzle.startTime = Date.now();
                puzzle.startTimer();
            }
            
            // Place all pieces in their correct positions
            puzzle.pieces.forEach(piece => {
                piece.placed = true;
                piece.currentRow = piece.correctRow;
                piece.currentCol = piece.correctCol;
                piece.x = piece.correctCol * puzzle.pieceWidth;
                piece.y = piece.correctRow * puzzle.pieceHeight;
            });
            
            // Update move count to simulate some moves
            puzzle.moveCount = puzzle.pieces.length;
            puzzle.correctMoves = puzzle.pieces.length; // All moves were "correct"
            
            // Trigger completion
            puzzle.render();
            puzzle.updateDisplay();
            puzzle.checkWin();
            
            console.log('‚úÖ Puzzle auto-solved! Completion modal should appear.');
        }
        
        function closeModal() {
            document.getElementById('completionModal').style.display = 'none';
        }
        
        function copyResults() {
            const resultsCode = document.getElementById('resultsCode').textContent;
            navigator.clipboard.writeText(resultsCode).then(() => {
                alert('Results copied to clipboard!');
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = resultsCode;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Results copied to clipboard!');
            });
        }
        
        function downloadScreenshot() {
            const screenshot = puzzle.captureScreenshot();
            const link = document.createElement('a');
            link.download = `puzzle-completion-${puzzle.sessionId}.png`;
            link.href = screenshot;
            link.click();
        }
        
        function shareResults() {
            const resultsCode = document.getElementById('resultsCode').textContent;
            const text = `I just completed a jigsaw puzzle! üß©\n\nResults: ${resultsCode}\n\nTry it yourself!`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'Puzzle Completion',
                    text: text,
                    url: window.location.href
                });
            } else {
                copyResults();
                alert('Results copied! You can now paste and share them.');
            }
        }
        
        function saveScore() {
            const userName = document.getElementById('userName').value.trim();
            const userEmail = document.getElementById('userEmail').value.trim();
            
            if (!userName || !userEmail) {
                alert('Please enter both your name and email address.');
                return;
            }
            
            // Validate email format
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(userEmail)) {
                alert('Please enter a valid email address.');
                return;
            }
            
            // Create score entry
            const scoreEntry = {
                sessionId: puzzle.sessionId,
                name: userName,
                email: userEmail,
                completionTime: puzzle.endTime - puzzle.startTime,
                timeString: document.getElementById('finalTime').textContent,
                difficulty: puzzle.gridSize,
                moveCount: puzzle.moveCount,
                accuracy: Math.round((puzzle.correctMoves / puzzle.moveCount) * 100),
                completedAt: new Date().toISOString(),
                resultsCode: puzzle.generateResultsCode(puzzle.endTime - puzzle.startTime)
            };
            
            // Save to localStorage database
            saveToDatabase(scoreEntry);
            
            // Show success message and proceed to results
            alert(`Score saved successfully! Thank you ${userName}!`);
            showResultsSection();
        }
        
        function skipSaving() {
            showResultsSection();
        }
        
        function showResultsSection() {
            document.getElementById('userInfoForm').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'block';
        }
        
        function saveToDatabase(scoreEntry) {
            // Show loading state
            const saveBtn = document.getElementById('saveScoreBtn');
            const originalText = saveBtn.textContent;
            saveBtn.textContent = 'üíæ Saving...';
            saveBtn.disabled = true;
            
            // Send to server database
            fetch('/api/scores', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(scoreEntry)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Score saved to database:', data);
                
                // Also save to localStorage as backup
                let localScores = [];
                const existingScores = localStorage.getItem('puzzleScores');
                if (existingScores) {
                    try {
                        localScores = JSON.parse(existingScores);
                    } catch (e) {
                        localScores = [];
                    }
                }
                localScores.push(scoreEntry);
                localStorage.setItem('puzzleScores', JSON.stringify(localScores));
                
                // Show success and proceed
                alert(`Score saved successfully! Thank you ${scoreEntry.name}!`);
                showResultsSection();
            })
            .catch(error => {
                console.error('Error saving to database:', error);
                
                // Fallback to localStorage if server fails
                let localScores = [];
                const existingScores = localStorage.getItem('puzzleScores');
                if (existingScores) {
                    try {
                        localScores = JSON.parse(existingScores);
                    } catch (e) {
                        localScores = [];
                    }
                }
                localScores.push(scoreEntry);
                localStorage.setItem('puzzleScores', JSON.stringify(localScores));
                
                alert(`Score saved locally! (Server unavailable - will sync when server is available)\nThank you ${scoreEntry.name}!`);
                showResultsSection();
            })
            .finally(() => {
                // Restore button state
                saveBtn.textContent = originalText;
                saveBtn.disabled = false;
            });
        }
        
        function getLeaderboard(limit = 10, difficulty = null) {
            return fetch(`/api/leaderboard?limit=${limit}${difficulty ? `&difficulty=${difficulty}` : ''}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error('Error fetching leaderboard:', error);
                    // Fallback to localStorage
                    const scores = localStorage.getItem('puzzleScores');
                    if (scores) {
                        try {
                            return JSON.parse(scores).slice(0, limit);
                        } catch (e) {
                            return [];
                        }
                    }
                    return [];
                });
        }
        
        function exportDatabase() {
            fetch('/api/scores/export')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const dataStr = JSON.stringify(data, null, 2);
                    const dataBlob = new Blob([dataStr], {type: 'application/json'});
                    
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    link.download = `puzzle-scores-export-${new Date().toISOString().split('T')[0]}.json`;
                    link.click();
                })
                .catch(error => {
                    console.error('Error exporting from database:', error);
                    // Fallback to localStorage export
                    const scores = localStorage.getItem('puzzleScores');
                    if (scores) {
                        const dataStr = JSON.stringify({
                            total: JSON.parse(scores).length,
                            exported_at: new Date().toISOString(),
                            source: 'localStorage_fallback',
                            scores: JSON.parse(scores)
                        }, null, 2);
                        const dataBlob = new Blob([dataStr], {type: 'application/json'});
                        
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(dataBlob);
                        link.download = `puzzle-scores-local-${new Date().toISOString().split('T')[0]}.json`;
                        link.click();
                    } else {
                        alert('No scores available to export');
                    }
                });
        }
        
        function getStats() {
            return fetch('/api/stats')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error('Error fetching stats:', error);
                    return null;
                });
        }
        
        // Start the game when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
