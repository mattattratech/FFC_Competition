<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Farnborough FC Season Ticket Competition - Day 7 | Tratech Consulting</title>
    <link rel="icon" type="image/png" href="ticket.png">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700&display=swap');
        
        body {
            font-family: 'Poppins', sans-serif;
            background: #142435;
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-x: hidden;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            color: #FFFFFF;
        }
        
        .container {
            background: #FFFFFF;
            border-radius: 12px;
            padding: 30px 30px 20px 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            max-width: 1000px;
            width: 100%;
            color: #142435;
        }
        
        .header-branding {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
        }
        
        .tratech-logo {
            margin-bottom: 15px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .logo-image {
            max-height: 80px;
            max-width: 300px;
            height: auto;
            width: auto;
            object-fit: contain;
        }
        
        h1 {
            color: #142435;
            margin: 15px 0 10px 0;
            font-size: 28px;
            font-weight: 600;
            font-family: 'Poppins', sans-serif;
        }
        
        .competition-subtitle {
            color: #599678;
            font-size: 14px;
            font-style: italic;
            margin: 0;
            font-weight: 400;
        }
        
        .session-info {
            background: #f8f9fa;
            border: 2px solid #599678;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .session-id {
            font-family: 'Poppins', sans-serif;
            font-weight: 600;
            color: #599678;
            font-size: 16px;
        }
        
        .timer {
            font-size: 24px;
            font-weight: 600;
            color: #142435;
            margin: 10px 0;
            font-family: 'Poppins', sans-serif;
        }
        
        .status {
            font-size: 16px;
            margin: 5px 0;
            font-family: 'Poppins', sans-serif;
        }
        
        .status.not-started { color: #142435; }
        .status.in-progress { color: #599678; }
        .status.completed { color: #599678; }
        
        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        input[type="file"] {
            display: none;
        }
        
        label[for="imageInput"] {
            display: inline-block;
            cursor: pointer;
        }
        
        .btn {
            background: #599678;
            color: #FFFFFF;
            padding: 10px 20px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            font-family: 'Poppins', sans-serif;
            transition: background-color 0.2s ease;
            min-height: 44px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
        }
        
        .btn:hover {
            background: #4a8067;
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .btn.secondary {
            background: #142435;
        }
        
        .btn.secondary:hover {
            background: #0d1a28;
        }
        
        .btn.danger {
            background: #dc3545;
        }
        
        .btn.danger:hover {
            background: #c82333;
        }
        
        .btn.success {
            background: #599678;
        }
        
        .btn.success:hover {
            background: #4a8067;
        }
        
        select {
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #ddd;
            font-size: 14px;
        }
        
        .game-area {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .canvas-container {
            border: 2px solid #599678;
            border-radius: 8px;
            background: #f8f9fa;
            position: relative;
            overflow: hidden;
        }
        
        canvas {
            display: block;
            border-radius: 8px;
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        .highlight-target {
            animation: highlightPulse 1s ease-in-out infinite;
        }
        
        @keyframes highlightPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.7; }
        }
        
        body.dragging {
            cursor: grabbing !important;
        }
        
        body.dragging * {
            cursor: grabbing !important;
        }
        
        .info {
            text-align: center;
            margin-top: 10px;
            color: #666;
        }
        
        .completion-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(20, 36, 53, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .modal-content {
            background: #FFFFFF;
            padding: 30px;
            border-radius: 12px;
            text-align: center;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            color: #142435;
            font-family: 'Poppins', sans-serif;
            box-sizing: border-box;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }
        
        /* Ensure scrollable content is visually clear */
        .modal-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .modal-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 4px;
        }
        
        .modal-content::-webkit-scrollbar-thumb {
            background: #599678;
            border-radius: 4px;
        }
        
        .modal-content::-webkit-scrollbar-thumb:hover {
            background: #4a7d61;
        }
        
        .completion-time {
            font-size: 32px;
            font-weight: 600;
            color: #599678;
            margin: 20px 0;
            font-family: 'Poppins', sans-serif;
        }
        
        .results-code {
            background: #f8f9fa;
            border: 2px solid #599678;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Poppins', sans-serif;
            white-space: pre-line;
            word-wrap: break-word;
            margin: 20px 0;
            font-size: 14px;
            text-align: left;
            line-height: 1.4;
            color: #142435;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: #599678;
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .stats {
            display: flex;
            justify-content: space-around;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin: 20px 0;
            border: 1px solid #e9ecef;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 600;
            color: #599678;
            font-family: 'Poppins', sans-serif;
        }
        
        .stat-label {
            font-size: 12px;
            color: #142435;
            text-transform: uppercase;
            font-family: 'Poppins', sans-serif;
            font-weight: 500;
        }
        
        .footer-branding {
            text-align: center;
            margin-top: 40px;
            padding: 20px 0;
            border-top: 2px solid #599678;
            color: #FFFFFF;
        }
        
        .footer-branding p {
            margin: 5px 0;
            font-size: 14px;
            font-family: 'Poppins', sans-serif;
        }
        
        .footer-contact {
            font-size: 12px !important;
            opacity: 0.9;
            color: #FFFFFF;
        }
        
        /* Mobile Responsive Styles */
        @media (max-width: 768px) {
            body {
                padding: 10px;
            }
            
            .container {
                margin: 0;
                padding: 15px;
                border-radius: 10px;
                max-width: 100%;
            }
            
            h1 {
                font-size: 22px;
                margin: 10px 0 8px 0;
            }
            
            .logo-image {
                max-height: 60px;
                max-width: 250px;
            }
            
            .controls {
                gap: 8px;
                margin-bottom: 15px;
                justify-content: center;
            }
            
            .btn {
                padding: 12px 16px;
                font-size: 16px;
                min-height: 48px;
                display: inline-flex;
                align-items: center;
                justify-content: center;
            }
            
            .game-area {
                gap: 15px;
                flex-direction: column;
                align-items: center;
            }
            
            .canvas-container {
                width: 100%;
                max-width: 350px;
            }
            
            canvas {
                width: 100% !important;
                height: auto !important;
                max-width: 350px;
            }
            
            .stats {
                padding: 10px;
                margin: 15px 0;
                gap: 5px;
            }
            
            .stat {
                flex: 1;
                min-width: 70px;
            }
            
            .stat-value {
                font-size: 20px;
            }
            
            .stat-label {
                font-size: 11px;
            }
            
            .completion-modal {
                padding: 10px;
                align-items: flex-start;
                padding-top: 5vh;
            }
            
            .modal-content {
                padding: 20px;
                width: 95%;
                margin: 0;
                max-height: 90vh;
                overflow-y: auto;
                max-width: none;
                -webkit-overflow-scrolling: touch;
                position: relative;
            }
            
            .timer {
                font-size: 20px;
            }
            
            .session-id {
                font-size: 14px;
                word-break: break-all;
            }
        }
        
        @media (max-width: 480px) {
            body {
                padding: 5px;
            }
            
            .container {
                padding: 10px;
                border-radius: 8px;
            }
            
            h1 {
                font-size: 18px;
                line-height: 1.3;
            }
            
            .logo-image {
                max-height: 50px;
                max-width: 200px;
            }
            
            .controls {
                flex-direction: column;
                gap: 10px;
                width: 100%;
            }
            
            .controls .btn {
                width: 100%;
                max-width: 300px;
            }
            
            .canvas-container {
                max-width: calc(100vw - 30px);
            }
            
            canvas {
                max-width: calc(100vw - 30px) !important;
            }
            
            .completion-modal {
                padding: 5px;
                align-items: flex-start;
                padding-top: 3vh;
            }
            
            .modal-content {
                padding: 15px;
                width: calc(100% - 10px);
                border-radius: 8px;
                margin: 0;
                max-height: 94vh;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .completion-time {
                font-size: 24px;
            }
            
            /* Mobile form improvements */
            .modal-content input {
                padding: 12px !important;
                font-size: 16px !important;
                border-radius: 8px !important;
                margin: 8px 0 !important;
            }
            
            .modal-content .btn {
                padding: 12px 20px !important;
                font-size: 16px !important;
                margin: 5px !important;
                min-height: 48px !important;
            }
            
            .modal-content h2 {
                font-size: 24px !important;
                margin: 0 0 15px 0 !important;
            }
            
            .modal-content h3 {
                font-size: 20px !important;
                margin: 15px 0 10px 0 !important;
            }
            
            .modal-content p {
                font-size: 14px !important;
                line-height: 1.4 !important;
                margin: 10px 0 !important;
            }
            
            .results-code {
                font-size: 12px;
                padding: 10px;
            }
        }
        
        /* Touch-friendly improvements */
        @media (pointer: coarse) {
            .btn {
                min-height: 48px;
                padding: 12px 20px;
            }
            
            canvas {
                touch-action: manipulation;
            }
            
            .canvas-container {
                user-select: none;
                -webkit-user-select: none;
                touch-action: manipulation;
            }
            
            /* Ensure body can scroll */
            body {
                touch-action: pan-y;
            }
        }
        
        /* Orientation-specific styles */
        .orientation-message {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #142435;
            z-index: 2000;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .orientation-content {
            background: white;
            border-radius: 20px;
            padding: 40px 30px;
            max-width: 350px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        .rotate-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: rotatePhone 2s ease-in-out infinite;
        }
        
        @keyframes rotatePhone {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
        }
        
        .orientation-title {
            font-size: 24px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
        }
        
        .orientation-text {
            color: #666;
            font-size: 16px;
            line-height: 1.5;
            margin-bottom: 20px;
        }
        
        .orientation-subtitle {
            color: #4CAF50;
            font-size: 14px;
            font-weight: bold;
        }
        
        /* Show orientation message only on mobile/tablet in portrait mode */
        @media screen and (max-width: 1024px) and (orientation: portrait) {
            .orientation-message {
                display: flex;
            }
            
            .container {
                display: none;
            }
        }
        
        /* Optimize landscape mode for mobile devices */
        @media screen and (max-width: 1024px) and (orientation: landscape) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 15px;
                max-width: 100%;
            }
            
            h1 {
                font-size: 20px;
                margin: 8px 0;
            }
            
            .logo-image {
                max-height: 50px;
            }
            
            .session-info {
                padding: 10px;
                margin-bottom: 15px;
            }
            
            .stats {
                padding: 8px;
                margin: 10px 0;
            }
            
            .controls {
                margin-bottom: 10px;
                gap: 8px;
            }
            
            .btn {
                padding: 8px 12px;
                font-size: 14px;
                min-height: 40px;
            }
            
            .game-area {
                gap: 15px;
                flex-direction: row;
                justify-content: center;
                flex-wrap: nowrap;
                align-items: flex-start;
            }
            
            .canvas-container {
                max-width: 380px;
                width: auto;
            }
            
            canvas {
                max-width: 380px !important;
                height: auto !important;
                width: auto !important;
            }
            
            .timer {
                font-size: 18px;
            }
            
            .session-id {
                font-size: 12px;
            }
            
            /* Make stats more compact for landscape */
            .stats {
                flex-direction: row;
                justify-content: space-around;
            }
            
            .stat {
                min-width: auto;
                margin: 0 5px;
            }
            
            .stat-value {
                font-size: 16px;
            }
            
            .stat-label {
                font-size: 10px;
            }
        }
        
        /* Footer Styles */
        .footer {
            background: #142435;
            color: #FFFFFF;
            padding: 40px 0 20px 0;
            margin-top: 40px;
            font-family: 'Poppins', sans-serif;
        }
        
        .footer-content {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
        }
        
        .footer-section h3 {
            color: #599678;
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 15px;
            border-bottom: 2px solid #599678;
            padding-bottom: 8px;
        }
        
        .footer-section ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        
        .footer-section ul li {
            margin-bottom: 8px;
        }
        
        .footer-section ul li a {
            color: #FFFFFF;
            text-decoration: none;
            font-size: 14px;
            transition: color 0.3s ease;
        }
        
        .footer-section ul li a:hover {
            color: #599678;
        }
        
        .footer-contact p {
            margin: 8px 0;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .footer-contact strong {
            color: #599678;
        }
        
        .footer-accreditations {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .accreditation-logo {
            height: 40px;
            width: auto;
            opacity: 0.8;
            transition: opacity 0.3s ease;
        }
        
        .accreditation-logo:hover {
            opacity: 1;
        }
        
        .social-links {
            display: flex;
            gap: 15px;
            margin-top: 15px;
        }
        
        .social-link {
            display: inline-block;
            width: 40px;
            height: 40px;
            background: #599678;
            border-radius: 50%;
            text-align: center;
            line-height: 40px;
            color: #FFFFFF;
            text-decoration: none;
            transition: background-color 0.3s ease;
            font-size: 18px;
        }
        
        .social-link:hover {
            background: #4a8067;
        }
        
        .footer-bottom {
            border-top: 1px solid #444;
            margin-top: 30px;
            padding-top: 20px;
            text-align: center;
        }
        
        .footer-bottom p {
            margin: 5px 0;
            font-size: 12px;
            color: #ccc;
        }
        
        .footer-bottom a {
            color: #599678;
            text-decoration: none;
        }
        
        .footer-bottom a:hover {
            text-decoration: underline;
        }
        
        @media (max-width: 768px) {
            .footer-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .footer-accreditations {
                justify-content: center;
            }
            
            .social-links {
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <!-- Orientation Message for Portrait Mode -->
    <div class="orientation-message">
        <div class="orientation-content">
            <div class="rotate-icon">📱</div>
            <div class="orientation-title">Please Rotate Your Device</div>
            <div class="orientation-text">
                This puzzle is designed for landscape mode to give you the best playing experience with larger, easier-to-drag pieces.
            </div>
            <div class="orientation-subtitle">🔄 Turn your device sideways to continue</div>
        </div>
    </div>

    <div class="container">
        <div class="header-branding">
            <div class="tratech-logo">
                <img src="logowithbackground.png" alt="Tratech Consulting" class="logo-image">
            </div>
            <h1>⚽ Farnborough FC Season Ticket Competition - Day 7</h1>
            <p class="competition-subtitle">Powered by Tratech Consulting</p>
        </div>
        
        <div class="session-info">
            <div>Session ID: <span class="session-id" id="sessionId"></span></div>
            <div class="timer" id="timer">00:00:00</div>
            <div class="status not-started" id="status">Ready to start - Move your first piece to begin!</div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-value" id="piecesPlaced">0</div>
                <div class="stat-label">Pieces Placed</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="totalPieces">64</div>
                <div class="stat-label">Total Pieces</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="accuracy">0%</div>
                <div class="stat-label" title="Percentage of pieces placed correctly on first attempt">Accuracy</div>
            </div>
        </div>
        
        <div class="controls" style="justify-content: center;">
            <button class="btn secondary" onclick="resetPuzzle()">
                🔄 Reset Puzzle
            </button>
        </div>
        
        <div class="game-area">
            <div class="canvas-container">
                <canvas id="puzzleCanvas" width="400" height="400"></canvas>
                <div class="info">Puzzle Board - Drop pieces here!</div>
            </div>
            <div class="canvas-container">
                <canvas id="piecesCanvas" width="400" height="400"></canvas>
                <div class="info">Puzzle Pieces - Drag to solve!</div>
            </div>
        </div>
    </div>
    

    <div class="completion-modal" id="completionModal">
        <div class="modal-content">
            <h2>🎉 Puzzle Completed! 🎉</h2>
            <div class="completion-time" id="finalTime"></div>
            <p>Congratulations! You've successfully completed the puzzle.</p>
            
            <div id="userInfoForm" style="margin: 20px 0;">
                <h3>Save Your Score!</h3>
                <p>Enter your details to save this completion to the leaderboard:</p>
                <div style="margin: 10px 0;">
                    <input type="text" id="userName" placeholder="Your Name" style="width: 100%; padding: 10px; margin: 5px 0; border: 1px solid #ddd; border-radius: 5px;">
                </div>
                <div style="margin: 10px 0;">
                    <input type="email" id="userEmail" placeholder="Your Email" style="width: 100%; padding: 10px; margin: 5px 0; border: 1px solid #ddd; border-radius: 5px;">
                </div>
                <button class="btn success" onclick="saveScore()" id="saveScoreBtn">💾 Save Score</button>
            </div>
            
            <div id="resultsSection" style="display: none;">
                <h3>🎉 Congratulations on making it through to Day 7! 🎉</h3>
                <p style="margin: 15px 0; font-size: 16px; color: #4CAF50; font-weight: bold;">Please follow this link to upload your answers to all the clues from the week. Please remember, it is one entry per person.</p>
                <h4>Your Results:</h4>
                <div class="results-code" id="resultsCode"></div>
                
                <div style="margin: 20px 0;">
                    <button class="btn success" onclick="copyResults()">📋 Copy Results</button>
                    <button class="btn secondary" onclick="downloadScreenshot()">📷 Download Screenshot</button>
                    <button class="btn" onclick="shareResults()">📤 Share Results</button>
                </div>
                
                <button class="btn success" onclick="submitQuizAnswers()">📝 Submit Quiz Answers</button>
            </div>
        </div>
    </div>

    <script>
        class CompetitionJigsawPuzzle {
            constructor() {
                this.puzzleCanvas = document.getElementById('puzzleCanvas');
                this.piecesCanvas = document.getElementById('piecesCanvas');
                this.puzzleCtx = this.puzzleCanvas.getContext('2d');
                this.piecesCtx = this.piecesCanvas.getContext('2d');
                
                this.sessionId = this.generateSessionId();
                this.image = null;
                this.pieces = [];
                this.gridSize = 8;
                console.log('🏗️ Constructor set gridSize to:', this.gridSize);
                this.pieceWidth = 0;
                this.pieceHeight = 0;
                this.draggedPiece = null;
                this.dragOffset = { x: 0, y: 0 };
                this.dragSource = null;
                this.originalPosition = null;
                
                // Timer and progress tracking
                this.startTime = null;
                this.endTime = null;
                this.timerInterval = null;
                this.gameStarted = false;
                this.gameCompleted = false;
                this.moveCount = 0;
                this.correctMoves = 0;
                
                // Rendering optimization
                this.renderPending = false;
                this.staticContentDirty = true;
                
                // Mobile support
                this.isMobile = window.innerWidth <= 1024;
                this.isLandscape = window.innerWidth > window.innerHeight;
                this.canvasSize = this.getOptimalCanvasSize();
                
                this.setupCanvasSize();
                this.initializeSession();
                this.initEventListeners();
                this.loadFromStorage();
            }
            
            getOptimalCanvasSize() {
                if (!this.isMobile) {
                    return 400; // Desktop size
                }
                
                if (this.isLandscape) {
                    // In landscape mode, use larger size for better touch interaction
                    const availableWidth = window.innerWidth / 2 - 40; // Half screen minus padding
                    const availableHeight = window.innerHeight - 150; // Screen height minus UI
                    const size = Math.min(380, Math.max(320, Math.min(availableWidth, availableHeight)));
                    console.log('Mobile landscape - calculated canvas size:', size);
                    return size;
                } else {
                    // Portrait mode (though this will be hidden)
                    const availableWidth = window.innerWidth - 50;
                    const size = Math.min(350, Math.max(250, availableWidth));
                    console.log('Mobile portrait - window width:', window.innerWidth, 'available:', availableWidth, 'canvas size:', size);
                    return size;
                }
            }
            
            setupCanvasSize() {
                console.log('Setting up canvas size:', this.canvasSize);
                console.log('Is mobile:', this.isMobile, 'Is landscape:', this.isLandscape);
                
                // Set canvas size based on device
                this.puzzleCanvas.width = this.canvasSize;
                this.puzzleCanvas.height = this.canvasSize;
                this.piecesCanvas.width = this.canvasSize;
                this.piecesCanvas.height = this.canvasSize;
                
                // Update piece dimensions
                this.pieceWidth = this.canvasSize / this.gridSize;
                this.pieceHeight = this.canvasSize / this.gridSize;
                
                console.log('Canvas dimensions set to:', this.canvasSize, 'x', this.canvasSize);
                console.log('Piece dimensions:', this.pieceWidth, 'x', this.pieceHeight);
                
                // Handle window resize and orientation change
                window.addEventListener('resize', () => {
                    const wasMobile = this.isMobile;
                    const wasLandscape = this.isLandscape;
                    
                    this.isMobile = window.innerWidth <= 1024;
                    this.isLandscape = window.innerWidth > window.innerHeight;
                    const newCanvasSize = this.getOptimalCanvasSize();
                    
                    if (newCanvasSize !== this.canvasSize || wasMobile !== this.isMobile || wasLandscape !== this.isLandscape) {
                        this.canvasSize = newCanvasSize;
                        this.pieceWidth = this.canvasSize / this.gridSize;
                        this.pieceHeight = this.canvasSize / this.gridSize;
                        
                        // Update canvas dimensions
                        this.puzzleCanvas.width = this.canvasSize;
                        this.puzzleCanvas.height = this.canvasSize;
                        this.piecesCanvas.width = this.canvasSize;
                        this.piecesCanvas.height = this.canvasSize;
                        
                        // Reposition existing pieces for new canvas size
                        if (this.pieces.length > 0) {
                            console.log('Repositioning pieces for new canvas size...');
                            
                            // Update positions for placed pieces on the puzzle grid
                            this.pieces.forEach(piece => {
                                if (piece.placed) {
                                    // Pieces on puzzle grid are positioned by their grid coordinates
                                    // No need to update x,y as they're calculated during rendering
                                } else {
                                    // Pieces on pieces canvas need repositioning
                                    // This will be handled by shufflePieces
                                }
                            });
                            
                            this.shufflePieces();
                        }
                        
                        // Mark static content as dirty and re-render
                        this.staticContentDirty = true;
                        this.render();
                        console.log('Canvas resized and re-rendered');
                    }
                });
            }
            
            generateSessionId() {
                const timestamp = Date.now().toString(36);
                const random = Math.random().toString(36).substr(2, 5);
                return `PUZZLE-${timestamp}-${random}`.toUpperCase();
            }
            
            initializeSession() {
                document.getElementById('sessionId').textContent = this.sessionId;
                this.updateDisplay();
            }
            
            initEventListeners() {
                // Remove difficulty selector event listener since we removed the element
                // this.gridSize is fixed at 8 for competition
                
                // Mouse events on both canvases
                this.piecesCanvas.addEventListener('mousedown', (e) => this.onMouseDown(e, 'pieces'));
                this.puzzleCanvas.addEventListener('mousedown', (e) => this.onMouseDown(e, 'puzzle'));
                
                // Global mouse events for dragging
                document.addEventListener('mousemove', (e) => this.onMouseMove(e));
                document.addEventListener('mouseup', (e) => this.onMouseUp(e));
                
                // Touch events on both canvases
                this.piecesCanvas.addEventListener('touchstart', (e) => this.onTouchStart(e, 'pieces'), { passive: false });
                this.puzzleCanvas.addEventListener('touchstart', (e) => this.onTouchStart(e, 'puzzle'), { passive: false });
                
                // Global touch events for dragging - only prevent default when actually dragging
                document.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
                document.addEventListener('touchend', (e) => this.onTouchEnd(e), { passive: false });
                
                // Auto-save every 5 seconds
                setInterval(() => this.saveToStorage(), 5000);
            }
            
            saveToStorage() {
                if (!this.pieces.length) return;
                
                const gameState = {
                    sessionId: this.sessionId,
                    gridSize: this.gridSize,
                    pieces: this.pieces.map(p => ({
                        id: p.id,
                        correctRow: p.correctRow,
                        correctCol: p.correctCol,
                        currentRow: p.currentRow,
                        currentCol: p.currentCol,
                        x: p.x,
                        y: p.y,
                        placed: p.placed
                    })),
                    gameStarted: this.gameStarted,
                    gameCompleted: this.gameCompleted,
                    startTime: this.startTime,
                    endTime: this.endTime,
                    moveCount: this.moveCount,
                    correctMoves: this.correctMoves,
                    imageData: this.image ? this.image.src : null
                };
                
                localStorage.setItem('puzzleGameState', JSON.stringify(gameState));
            }
            
            loadFromStorage() {
                const saved = localStorage.getItem('puzzleGameState');
                if (!saved) {
                    this.loadDefaultImage();
                    return;
                }
                
                try {
                    const gameState = JSON.parse(saved);
                    
                    // Restore basic state
                    this.gameCompleted = gameState.gameCompleted;
                    
                    // Difficulty is fixed at 8x8 for competition - override any saved value
                    this.gridSize = 8;
                    console.log('🔧 Grid size forced to 8x8 for competition:', this.gridSize);
                    
                    // Reset timer and move tracking on each page load for fresh start
                    this.gameStarted = false;
                    this.startTime = null;
                    this.endTime = gameState.gameCompleted ? gameState.endTime : null;
                    this.moveCount = 0;
                    this.correctMoves = 0;
                    
                    // Restore image and pieces
                    if (gameState.imageData && gameState.pieces && gameState.pieces.length > 0) {
                        // Check if saved pieces match expected 8x8 grid (64 pieces)
                        const expectedPieceCount = this.gridSize * this.gridSize;
                        
                        if (gameState.pieces.length !== expectedPieceCount) {
                            console.log(`Piece count mismatch: saved ${gameState.pieces.length}, expected ${expectedPieceCount}. Recreating puzzle.`);
                            this.loadDefaultImage();
                            return;
                        }
                        
                        this.image = new Image();
                        this.image.onload = () => {
                            this.pieceWidth = this.canvasSize / this.gridSize;
                            this.pieceHeight = this.canvasSize / this.gridSize;
                            this.pieces = gameState.pieces;
                            
                            // Validate and adjust piece positions for current canvas size
                            this.validatePiecePositions();
                            
                            this.render();
                            this.updateDisplay();
                            
                            // Timer will start fresh on first move
                            this.resetTimerDisplay();
                        };
                        this.image.onerror = () => {
                            console.error('Failed to restore saved image, loading default');
                            this.loadDefaultImage();
                        };
                        this.image.src = gameState.imageData;
                    } else {
                        this.loadDefaultImage();
                    }
                    
                } catch (e) {
                    console.error('Failed to load saved game:', e);
                    this.loadDefaultImage();
                }
            }
            
            loadDefaultImage() {
                console.log('🖼️ Loading default image...');
                this.image = new Image();
                this.image.onload = () => {
                    console.log('✅ Successfully loaded smarty.jpg');
                    console.log('Image dimensions:', this.image.width, 'x', this.image.height);
                    this.createPuzzle();
                };
                this.image.onerror = (e) => {
                    console.error('❌ Failed to load smarty.jpg:', e);
                    console.log('🎨 Creating fallback image...');
                    this.createFallbackImage();
                };
                
                // Try to load smarty.jpg from the same directory
                console.log('📂 Attempting to load: smarty.jpg');
                this.image.src = 'smarty.jpg';
            }
            
            createFallbackImage() {
                // Create a simple colored pattern as fallback
                // Always use 400x400 for consistent image sampling
                const canvas = document.createElement('canvas');
                canvas.width = 400;
                canvas.height = 400;
                const ctx = canvas.getContext('2d');
                
                // Create a colorful pattern
                for (let i = 0; i < 8; i++) {
                    for (let j = 0; j < 8; j++) {
                        const hue = (i * 8 + j) * 45;
                        ctx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                        ctx.fillRect(i * 50, j * 50, 50, 50);
                        
                        // Add some text
                        ctx.fillStyle = 'white';
                        ctx.font = '16px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText(`${i * 8 + j + 1}`, i * 50 + 25, j * 50 + 30);
                    }
                }
                
                this.image = new Image();
                this.image.onload = () => this.createPuzzle();
                this.image.src = canvas.toDataURL();
            }
            
            loadImage(file) {
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    this.image = new Image();
                    this.image.onload = () => this.createPuzzle();
                    this.image.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
            
            createPuzzle() {
                console.log('=== Creating puzzle ===');
                console.log('Canvas size:', this.canvasSize);
                console.log('Grid size:', this.gridSize);
                
                this.resetGame();
                this.pieces = [];
                this.pieceWidth = this.canvasSize / this.gridSize;
                this.pieceHeight = this.canvasSize / this.gridSize;
                
                console.log(`Creating ${this.gridSize}x${this.gridSize} puzzle with ${this.pieceWidth}x${this.pieceHeight}px pieces`);
                
                // Create pieces
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const piece = {
                            id: row * this.gridSize + col,
                            correctRow: row,
                            correctCol: col,
                            currentRow: -1,
                            currentCol: -1,
                            x: 0,
                            y: 0,
                            placed: false
                        };
                        this.pieces.push(piece);
                    }
                }
                
                console.log(`Created ${this.pieces.length} pieces total`);
                console.log(`Expected: ${this.gridSize * this.gridSize} pieces`);
                console.log(`First piece:`, this.pieces[0]);
                console.log(`Last piece:`, this.pieces[this.pieces.length - 1]);
                
                this.shufflePieces();
                this.updateDisplay();
                this.render();
            }
            
            shufflePieces() {
                if (!this.pieces.length) return;
                
                console.log(`Shuffling ${this.pieces.length} pieces in ${this.gridSize}x${this.gridSize} grid`);
                console.log(`Canvas size: ${this.canvasSize}, Piece size: ${this.pieceWidth}x${this.pieceHeight}`);
                
                // Reset all pieces that are placed
                this.pieces.forEach(piece => {
                    if (piece.placed) {
                        piece.placed = false;
                        piece.currentRow = -1;
                        piece.currentCol = -1;
                    }
                });
                
                // Mark static content as dirty
                this.staticContentDirty = true;
                
                // Create a shuffled array of all positions in the pieces canvas
                const allPositions = [];
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        allPositions.push({ 
                            row, 
                            col,
                            x: col * this.pieceWidth,
                            y: row * this.pieceHeight
                        });
                    }
                }
                
                // Shuffle the positions array
                for (let i = allPositions.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allPositions[i], allPositions[j]] = [allPositions[j], allPositions[i]];
                }
                
                // Assign each piece a unique random position using current canvas/piece dimensions
                this.pieces.forEach((piece, index) => {
                    const position = allPositions[index];
                    // Ensure exact grid positioning
                    const snappedPos = this.snapToGridXY(position.x, position.y);
                    piece.x = snappedPos.x;
                    piece.y = snappedPos.y;
                    
                    // Debug: check if pieces are positioned outside canvas
                    if (piece.x + this.pieceWidth > this.canvasSize || piece.y + this.pieceHeight > this.canvasSize) {
                        console.warn(`Piece ${piece.id} positioned outside canvas: (${piece.x}, ${piece.y}) - canvas: ${this.canvasSize}x${this.canvasSize}`);
                    }
                });
                
                console.log(`Repositioned all ${this.pieces.length} pieces with current dimensions`);
                console.log(`Sample positions:`, this.pieces.slice(0, 3).map(p => `Piece ${p.id}: (${p.x}, ${p.y})`));
                console.log(`Grid step: ${this.pieceWidth}px`);
                
                this.render();
            }
            
            validatePiecePositions() {
                if (!this.pieces.length) return;
                
                console.log('Validating piece positions for current canvas size...');
                
                // Check if any pieces are positioned outside the canvas or have invalid dimensions
                let needsRepositioning = false;
                
                this.pieces.forEach(piece => {
                    // Check if piece is outside canvas bounds
                    if (piece.x + this.pieceWidth > this.canvasSize || 
                        piece.y + this.pieceHeight > this.canvasSize ||
                        piece.x < 0 || piece.y < 0) {
                        needsRepositioning = true;
                        console.warn(`Piece ${piece.id} outside canvas bounds: (${piece.x}, ${piece.y})`);
                    }
                    
                    // Check if piece positions are properly grid-aligned
                    const expectedX = Math.round(piece.x / this.pieceWidth) * this.pieceWidth;
                    const expectedY = Math.round(piece.y / this.pieceHeight) * this.pieceHeight;
                    
                    if (Math.abs(piece.x - expectedX) > 1 || Math.abs(piece.y - expectedY) > 1) {
                        piece.x = expectedX;
                        piece.y = expectedY;
                        console.log(`Snapped piece ${piece.id} to grid: (${piece.x}, ${piece.y})`);
                    }
                });
                
                // If pieces are outside bounds, reshuffle them
                if (needsRepositioning) {
                    console.log('Pieces found outside canvas bounds - reshuffling...');
                    this.shufflePieces();
                }
            }
            
            startTimer() {
                if (this.timerInterval) return;
                
                this.timerInterval = setInterval(() => {
                    this.updateTimer();
                }, 1000);
            }
            
            stopTimer() {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                    this.timerInterval = null;
                }
            }
            
            updateTimer() {
                if (!this.startTime) return;
                
                const now = this.gameCompleted ? this.endTime : Date.now();
                const elapsed = Math.floor((now - this.startTime) / 1000);
                
                const hours = Math.floor(elapsed / 3600);
                const minutes = Math.floor((elapsed % 3600) / 60);
                const seconds = elapsed % 60;
                
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                document.getElementById('timer').textContent = timeString;
            }
            
            resetTimerDisplay() {
                document.getElementById('timer').textContent = '00:00:00';
            }
            
            updateDisplay() {
                const placedPieces = this.pieces.filter(p => p.placed).length;
                const totalPieces = this.pieces.length;
                const correctlyPlacedPieces = this.pieces.filter(p => 
                    p.placed && p.currentRow === p.correctRow && p.currentCol === p.correctCol
                ).length;
                
                const progress = totalPieces > 0 ? (placedPieces / totalPieces) * 100 : 0;
                const accuracy = this.moveCount > 0 ? Math.round((this.correctMoves / this.moveCount) * 100) : 0;
                
                console.log(`Display update: ${placedPieces}/${totalPieces} pieces placed, ${correctlyPlacedPieces} correct, ${this.correctMoves}/${this.moveCount} moves correct (${accuracy}%)`);
                
                document.getElementById('piecesPlaced').textContent = placedPieces;
                document.getElementById('totalPieces').textContent = totalPieces;
                document.getElementById('accuracy').textContent = accuracy + '%';
                document.getElementById('progressFill').style.width = progress + '%';
                
                // Update status
                const statusEl = document.getElementById('status');
                if (this.gameCompleted) {
                    statusEl.textContent = 'Puzzle completed! 🎉';
                    statusEl.className = 'status completed';
                } else if (this.gameStarted) {
                    statusEl.textContent = `In progress - ${placedPieces}/${totalPieces} pieces placed`;
                    statusEl.className = 'status in-progress';
                } else {
                    statusEl.textContent = 'Ready to start - Move your first piece to begin!';
                    statusEl.className = 'status not-started';
                }
            }
            
            render() {
                // Use requestAnimationFrame to prevent excessive redraws
                if (this.renderPending) return;
                this.renderPending = true;
                
                requestAnimationFrame(() => {
                    this.doRender();
                    this.renderPending = false;
                });
            }
            
            // Force immediate render without throttling
            forceRender() {
                this.doRender();
            }
            
            doRender() {
                console.log('Rendering - canvas size:', this.canvasSize, 'pieces:', this.pieces.length);
                // Only clear and redraw when necessary
                this.renderStaticContent();
                this.renderDraggedPiece();
            }
            
            renderStaticContent() {
                // Always clear both canvases when dragging to prevent multiple instances
                if (this.draggedPiece || this.staticContentDirty) {
                    // Clear both canvases
                    this.puzzleCtx.clearRect(0, 0, this.canvasSize, this.canvasSize);
                    this.piecesCtx.clearRect(0, 0, this.canvasSize, this.canvasSize);
                    
                    // Draw grid
                    this.drawGrid(this.puzzleCtx);
                    this.drawGrid(this.piecesCtx);
                    
                    // Draw all static pieces (not being dragged)
                    this.pieces.forEach(piece => {
                        if (piece === this.draggedPiece) return;
                        
                        if (piece.placed) {
                            this.drawPiece(this.puzzleCtx, piece, 
                                piece.currentCol * this.pieceWidth, 
                                piece.currentRow * this.pieceHeight);
                        } else {
                            this.drawPiece(this.piecesCtx, piece, piece.x, piece.y);
                        }
                    });
                    
                    this.staticContentDirty = false;
                }
            }
            
            renderDraggedPiece() {
                if (!this.draggedPiece) {
                    // Clear any existing highlight when not dragging
                    if (this.lastHighlight) {
                        this.clearHighlight();
                        this.lastHighlight = null;
                    }
                    return;
                }
                
                // Clear previous highlight first
                if (this.lastHighlight) {
                    this.clearHighlight();
                }
                
                // Calculate and draw new highlight
                this.drawDropZoneHighlight();
                
                // Only draw dragged piece ONCE - determine which canvas based on mouse position
                this.drawDraggedPieceOnCorrectCanvas();
            }
            
            drawDraggedPieceOnCorrectCanvas() {
                if (!this.draggedPiece || !this.draggedPiece.globalX || !this.draggedPiece.globalY) {
                    // Fallback to pieces canvas
                    this.drawPiece(this.piecesCtx, this.draggedPiece, 
                        this.draggedPiece.x, this.draggedPiece.y);
                    return;
                }
                
                const puzzleRect = this.puzzleCanvas.getBoundingClientRect();
                const piecesRect = this.piecesCanvas.getBoundingClientRect();
                
                // Determine which canvas the mouse is primarily over
                const overPuzzle = this.draggedPiece.globalX >= puzzleRect.left && 
                                   this.draggedPiece.globalX <= puzzleRect.right &&
                                   this.draggedPiece.globalY >= puzzleRect.top && 
                                   this.draggedPiece.globalY <= puzzleRect.bottom;
                
                if (overPuzzle) {
                    // Draw on puzzle canvas with mouse-relative positioning
                    const puzzleX = this.draggedPiece.globalX - puzzleRect.left - this.dragOffset.x;
                    const puzzleY = this.draggedPiece.globalY - puzzleRect.top - this.dragOffset.y;
                    this.drawPiece(this.puzzleCtx, this.draggedPiece, puzzleX, puzzleY);
                } else {
                    // Draw on pieces canvas with calculated positioning
                    this.drawPiece(this.piecesCtx, this.draggedPiece, 
                        this.draggedPiece.x, this.draggedPiece.y);
                }
            }
            
            clearHighlight() {
                if (!this.lastHighlight) return;
                
                // Only clear the specific highlight area, then redraw static content there
                const { x, y, width, height } = this.lastHighlight;
                this.puzzleCtx.clearRect(x - 2, y - 2, width + 4, height + 4);
                
                // Redraw grid in cleared area
                this.puzzleCtx.save();
                this.puzzleCtx.strokeStyle = '#ddd';
                this.puzzleCtx.lineWidth = 1;
                this.puzzleCtx.beginPath();
                
                // Draw grid lines in cleared area
                for (let i = 0; i <= this.gridSize; i++) {
                    const pos = i * this.pieceWidth;
                    if (pos >= x - 2 && pos <= x + width + 2) {
                        this.puzzleCtx.moveTo(pos, Math.max(0, y - 2));
                        this.puzzleCtx.lineTo(pos, Math.min(this.canvasSize, y + height + 2));
                    }
                }
                for (let i = 0; i <= this.gridSize; i++) {
                    const pos = i * this.pieceHeight;
                    if (pos >= y - 2 && pos <= y + height + 2) {
                        this.puzzleCtx.moveTo(Math.max(0, x - 2), pos);
                        this.puzzleCtx.lineTo(Math.min(this.canvasSize, x + width + 2), pos);
                    }
                }
                this.puzzleCtx.stroke();
                this.puzzleCtx.restore();
                
                // Redraw any pieces in cleared area
                this.pieces.forEach(piece => {
                    if (piece.placed && piece !== this.draggedPiece) {
                        const pieceX = piece.currentCol * this.pieceWidth;
                        const pieceY = piece.currentRow * this.pieceHeight;
                        
                        // Check if piece overlaps with cleared area
                        if (pieceX < x + width && pieceX + this.pieceWidth > x &&
                            pieceY < y + height && pieceY + this.pieceHeight > y) {
                            this.drawPiece(this.puzzleCtx, piece, pieceX, pieceY);
                        }
                    }
                });
            }
            
            drawDropZoneHighlight() {
                if (!this.draggedPiece || !this.draggedPiece.globalX || !this.draggedPiece.globalY) return;
                
                const puzzleRect = this.puzzleCanvas.getBoundingClientRect();
                
                if (this.draggedPiece.globalX >= puzzleRect.left - 30 && 
                    this.draggedPiece.globalX <= puzzleRect.right + 30 &&
                    this.draggedPiece.globalY >= puzzleRect.top - 30 && 
                    this.draggedPiece.globalY <= puzzleRect.bottom + 30) {
                    
                    const x = Math.max(0, Math.min(this.draggedPiece.globalX - puzzleRect.left, this.canvasSize));
                    const y = Math.max(0, Math.min(this.draggedPiece.globalY - puzzleRect.top, this.canvasSize));
                    
                    let col = Math.floor(x / this.pieceWidth);
                    let row = Math.floor(y / this.pieceHeight);
                    
                    const cellX = x % this.pieceWidth;
                    const cellY = y % this.pieceHeight;
                    const margin = 3;
                    
                    if (!(cellX < margin || cellX > this.pieceWidth - margin ||
                          cellY < margin || cellY > this.pieceHeight - margin)) {
                        
                        col = Math.max(0, Math.min(col, this.gridSize - 1));
                        row = Math.max(0, Math.min(row, this.gridSize - 1));
                        
                        const occupiedPiece = this.pieces.find(p => 
                            p.placed && p.currentRow === row && p.currentCol === col && p !== this.draggedPiece);
                        
                        const highlightX = col * this.pieceWidth;
                        const highlightY = row * this.pieceHeight;
                        
                        // Store highlight info for clearing
                        this.lastHighlight = {
                            x: highlightX,
                            y: highlightY,
                            width: this.pieceWidth,
                            height: this.pieceHeight
                        };
                        
                        // Draw highlight
                        this.puzzleCtx.save();
                        if (occupiedPiece) {
                            this.puzzleCtx.fillStyle = 'rgba(255, 152, 0, 0.4)';
                            this.puzzleCtx.strokeStyle = '#FF9800';
                        } else {
                            this.puzzleCtx.fillStyle = 'rgba(76, 175, 80, 0.3)';
                            this.puzzleCtx.strokeStyle = '#4CAF50';
                        }
                        this.puzzleCtx.lineWidth = 3;
                        this.puzzleCtx.fillRect(highlightX, highlightY, this.pieceWidth, this.pieceHeight);
                        this.puzzleCtx.strokeRect(highlightX, highlightY, this.pieceWidth, this.pieceHeight);
                        this.puzzleCtx.restore();
                    }
                }
            }
            
            drawPiece(ctx, piece, x, y) {
                if (!this.image) {
                    console.warn('No image loaded for drawing pieces');
                    return;
                }
                
                ctx.save();
                
                // Calculate source coordinates from original image dimensions
                // Always use a fixed reference size (400px) for consistent image sampling
                const baseSize = 400;
                const basePieceSize = baseSize / this.gridSize;
                const sourceX = piece.correctCol * basePieceSize;
                const sourceY = piece.correctRow * basePieceSize;
                
                // Enhanced shadow and scaling for dragged pieces
                const isDragged = piece === this.draggedPiece;
                
                if (isDragged) {
                    // Stronger shadow for dragged piece
                    ctx.shadowColor = 'rgba(0,0,0,0.6)';
                    ctx.shadowBlur = 15;
                    ctx.shadowOffsetX = 5;
                    ctx.shadowOffsetY = 5;
                    
                    // Larger scale up for mobile devices
                    const scale = this.isMobile ? 1.15 : 1.05;
                    const scaledWidth = this.pieceWidth * scale;
                    const scaledHeight = this.pieceHeight * scale;
                    const offsetX = (scaledWidth - this.pieceWidth) / 2;
                    const offsetY = (scaledHeight - this.pieceHeight) / 2;
                    
                    // Draw scaled piece using consistent source coordinates
                    ctx.drawImage(
                        this.image,
                        sourceX, sourceY,
                        basePieceSize, basePieceSize,
                        x - offsetX, y - offsetY,
                        scaledWidth, scaledHeight
                    );
                    
                    // Draw border for dragged piece
                    ctx.shadowColor = 'transparent';
                    ctx.strokeStyle = '#2196F3'; // Blue border for dragged pieces
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x - offsetX, y - offsetY, scaledWidth, scaledHeight);
                } else {
                    // Normal shadow for non-dragged pieces
                    ctx.shadowColor = 'rgba(0,0,0,0.3)';
                    ctx.shadowBlur = 5;
                    ctx.shadowOffsetX = 2;
                    ctx.shadowOffsetY = 2;
                    
                    // Draw the piece image using consistent source coordinates
                    ctx.drawImage(
                        this.image,
                        sourceX, sourceY,
                        basePieceSize, basePieceSize,
                        x, y,
                        this.pieceWidth, this.pieceHeight
                    );
                    
                    // Draw border with correct placement indicator
                    ctx.shadowColor = 'transparent';
                    const isCorrectlyPlaced = piece.placed && 
                        piece.currentRow === piece.correctRow && 
                        piece.currentCol === piece.correctCol;
                    
                    if (isCorrectlyPlaced) {
                        ctx.strokeStyle = '#4CAF50'; // Green for correct placement
                        ctx.lineWidth = 3;
                        console.log(`Drawing green border for correctly placed piece ${piece.id} at (${piece.currentRow}, ${piece.currentCol})`);
                    } else {
                        ctx.strokeStyle = '#333'; // Dark gray for incorrect/unplaced
                        ctx.lineWidth = 2;
                        if (piece.placed) {
                            console.log(`Drawing gray border for incorrectly placed piece ${piece.id} at (${piece.currentRow}, ${piece.currentCol}) - should be at (${piece.correctRow}, ${piece.correctCol})`);
                        }
                    }
                    
                    ctx.strokeRect(x, y, this.pieceWidth, this.pieceHeight);
                }
                
                ctx.restore();
            }
            
            getMousePos(canvas, e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }
            
            getTouchPos(canvas, e) {
                const rect = canvas.getBoundingClientRect();
                return {
                    x: e.touches[0].clientX - rect.left,
                    y: e.touches[0].clientY - rect.top
                };
            }
            
            findPieceAt(x, y) {
                for (let i = this.pieces.length - 1; i >= 0; i--) {
                    const piece = this.pieces[i];
                    if (!piece.placed &&
                        x >= piece.x && x <= piece.x + this.pieceWidth &&
                        y >= piece.y && y <= piece.y + this.pieceHeight) {
                        return piece;
                    }
                }
                return null;
            }
            
            findPieceOnGrid(x, y) {
                const col = Math.floor(x / this.pieceWidth);
                const row = Math.floor(y / this.pieceHeight);
                
                if (row >= 0 && row < this.gridSize && col >= 0 && col < this.gridSize) {
                    return this.pieces.find(piece => 
                        piece.placed && piece.currentRow === row && piece.currentCol === col);
                }
                return null;
            }
            
            snapBackToOriginal() {
                if (!this.draggedPiece || !this.originalPosition) return;
                
                const piece = this.draggedPiece;
                const originalPos = this.originalPosition;
                
                console.log(`⬅️ Immediately snapping piece ${piece.id} back to original position`);
                
                // Immediately restore to original position - no animation
                piece.x = originalPos.x;
                piece.y = originalPos.y;
                piece.placed = originalPos.placed;
                piece.currentRow = originalPos.currentRow;
                piece.currentCol = originalPos.currentCol;
                
                // Clear drag state immediately
                this.draggedPiece = null;
                this.dragSource = null;
                this.originalPosition = null;
                document.body.classList.remove('dragging');
                
                // Force immediate re-render
                this.staticContentDirty = true;
                this.forceRender();
                this.updateDisplay();
                this.saveToStorage();
                
                console.log(`✅ Piece ${piece.id} snapped back immediately`);
            }
            
            onMouseDown(e, canvasType) {
                if (canvasType === 'pieces') {
                    // Handle pieces canvas - find unplaced pieces
                    const pos = this.getMousePos(this.piecesCanvas, e);
                    console.log(`Mouse down on pieces canvas at (${pos.x}, ${pos.y})`);
                    this.draggedPiece = this.findPieceAt(pos.x, pos.y);
                    
                    if (this.draggedPiece) {
                        this.dragOffset.x = pos.x - this.draggedPiece.x;
                        this.dragOffset.y = pos.y - this.draggedPiece.y;
                        this.dragSource = 'pieces';
                        // Store original position for snap-back
                        this.originalPosition = {
                            x: this.draggedPiece.x,
                            y: this.draggedPiece.y,
                            placed: false,
                            currentRow: -1,
                            currentCol: -1
                        };
                        document.body.classList.add('dragging');
                        console.log('Started dragging piece from pieces canvas', this.draggedPiece.id);
                    } else {
                        console.log('No piece found at mouse position');
                        // Debug: show all unplaced pieces and their positions
                        const unplacedPieces = this.pieces.filter(p => !p.placed);
                        console.log(`Unplaced pieces (${unplacedPieces.length}):`, 
                            unplacedPieces.slice(0, 5).map(p => `Piece ${p.id}: (${p.x}, ${p.y})`));
                    }
                } else if (canvasType === 'puzzle') {
                    // Handle puzzle canvas - find placed pieces
                    const pos = this.getMousePos(this.puzzleCanvas, e);
                    this.draggedPiece = this.findPieceOnGrid(pos.x, pos.y);
                    
                    if (this.draggedPiece) {
                        // Store original grid position for snap-back
                        this.originalPosition = {
                            x: this.draggedPiece.currentCol * this.pieceWidth,
                            y: this.draggedPiece.currentRow * this.pieceHeight,
                            placed: true,
                            currentRow: this.draggedPiece.currentRow,
                            currentCol: this.draggedPiece.currentCol
                        };
                        
                        // Remove from grid and move to pieces canvas coordinates
                        this.draggedPiece.placed = false;
                        this.draggedPiece.currentRow = -1;
                        this.draggedPiece.currentCol = -1;
                        
                        // Calculate initial position on pieces canvas
                        this.draggedPiece.x = pos.x;
                        this.draggedPiece.y = pos.y;
                        
                        this.dragOffset.x = 0;
                        this.dragOffset.y = 0;
                        this.dragSource = 'puzzle';
                        document.body.classList.add('dragging');
                        console.log('Started dragging piece from puzzle grid', this.draggedPiece.id);
                        
                        // Re-render to show piece removed from grid
                        this.render();
                        this.updateDisplay();
                    }
                }
            }
            
            drawGrid(ctx) {
                ctx.save();
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                // Draw all vertical lines in one path
                for (let i = 0; i <= this.gridSize; i++) {
                    const pos = i * this.pieceWidth;
                    ctx.moveTo(pos, 0);
                    ctx.lineTo(pos, this.canvasSize);
                }
                
                // Draw all horizontal lines in one path
                for (let i = 0; i <= this.gridSize; i++) {
                    const pos = i * this.pieceHeight;
                    ctx.moveTo(0, pos);
                    ctx.lineTo(this.canvasSize, pos);
                }
                
                ctx.stroke();
                ctx.restore();
            }
            
            onMouseMove(e) {
                if (this.draggedPiece) {
                    // Store global mouse position for drop zone highlighting
                    this.draggedPiece.globalX = e.clientX;
                    this.draggedPiece.globalY = e.clientY;
                    
                    // Calculate position relative to pieces canvas for rendering
                    const rect = this.piecesCanvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    this.draggedPiece.x = x - this.dragOffset.x;
                    this.draggedPiece.y = y - this.dragOffset.y;
                    
                    // Throttle rendering during drag to reduce flickering
                    this.render();
                }
            }
            
            onMouseUp(e) {
                if (this.draggedPiece) {
                    console.log('Mouse up - checking drop for piece', this.draggedPiece.id);
                    this.checkDrop(e);
                    
                    // Clear drag state
                    console.log('Clearing drag state');
                    const wasDropped = this.draggedPiece;
                    this.draggedPiece = null;
                    this.dragSource = null;
                    this.originalPosition = null;
                    document.body.classList.remove('dragging');
                    
                    // Force a complete re-render to ensure UI is updated
                    this.staticContentDirty = true;
                    this.render();
                    console.log('Forced re-render after drag end');
                }
            }
            
            onTouchStart(e, canvasType) {
                e.preventDefault();
                
                if (canvasType === 'pieces') {
                    // Handle pieces canvas - find unplaced pieces
                    const pos = this.getTouchPos(this.piecesCanvas, e);
                    this.draggedPiece = this.findPieceAt(pos.x, pos.y);
                    
                    if (this.draggedPiece) {
                        this.dragOffset.x = pos.x - this.draggedPiece.x;
                        this.dragOffset.y = pos.y - this.draggedPiece.y;
                        this.dragSource = 'pieces';
                        // Store original position for snap-back
                        this.originalPosition = {
                            x: this.draggedPiece.x,
                            y: this.draggedPiece.y,
                            placed: false,
                            currentRow: -1,
                            currentCol: -1
                        };
                        document.body.classList.add('dragging');
                        console.log('Started touch dragging piece from pieces canvas', this.draggedPiece.id);
                    }
                } else if (canvasType === 'puzzle') {
                    // Handle puzzle canvas - find placed pieces
                    const pos = this.getTouchPos(this.puzzleCanvas, e);
                    this.draggedPiece = this.findPieceOnGrid(pos.x, pos.y);
                    
                    if (this.draggedPiece) {
                        // Store original grid position for snap-back
                        this.originalPosition = {
                            x: this.draggedPiece.currentCol * this.pieceWidth,
                            y: this.draggedPiece.currentRow * this.pieceHeight,
                            placed: true,
                            currentRow: this.draggedPiece.currentRow,
                            currentCol: this.draggedPiece.currentCol
                        };
                        
                        // Remove from grid and move to pieces canvas coordinates
                        this.draggedPiece.placed = false;
                        this.draggedPiece.currentRow = -1;
                        this.draggedPiece.currentCol = -1;
                        
                        // Calculate initial position on pieces canvas
                        this.draggedPiece.x = pos.x;
                        this.draggedPiece.y = pos.y;
                        
                        this.dragOffset.x = 0;
                        this.dragOffset.y = 0;
                        this.dragSource = 'puzzle';
                        document.body.classList.add('dragging');
                        console.log('Started touch dragging piece from puzzle grid', this.draggedPiece.id);
                        
                        // Re-render to show piece removed from grid
                        this.render();
                        this.updateDisplay();
                    }
                }
            }
            
            onTouchMove(e) {
                if (this.draggedPiece) {
                    // Only prevent default when actually dragging a piece
                    e.preventDefault();
                    
                    // Store global touch position for drop zone highlighting
                    this.draggedPiece.globalX = e.touches[0].clientX;
                    this.draggedPiece.globalY = e.touches[0].clientY;
                    
                    // Calculate position relative to pieces canvas for rendering
                    const rect = this.piecesCanvas.getBoundingClientRect();
                    const x = e.touches[0].clientX - rect.left;
                    const y = e.touches[0].clientY - rect.top;
                    
                    this.draggedPiece.x = x - this.dragOffset.x;
                    this.draggedPiece.y = y - this.dragOffset.y;
                    
                    // Throttle rendering during drag to reduce flickering
                    this.render();
                }
                // If not dragging, allow normal scrolling
            }
            
            onTouchEnd(e) {
                if (this.draggedPiece) {
                    e.preventDefault();
                    console.log('Touch end - checking drop');
                    this.checkDrop(e);
                    
                    // Clear drag state
                    console.log('Clearing touch drag state');
                    this.draggedPiece = null;
                    this.dragSource = null;
                    this.originalPosition = null;
                    document.body.classList.remove('dragging');
                    
                    // Force a complete re-render to ensure UI is updated
                    this.staticContentDirty = true;
                    this.render();
                    console.log('Forced re-render after touch end');
                }
                // If not dragging, allow normal touch behavior (no preventDefault)
            }
            
            checkDrop(e) {
                if (!this.draggedPiece) return;
                
                // Start game if not started
                if (!this.gameStarted) {
                    this.gameStarted = true;
                    this.startTime = Date.now();
                    this.startTimer();
                }
                
                this.moveCount++;
                
                // Get drop coordinates
                let clientX, clientY;
                if (e.type.includes('touch')) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }
                
                // Check if dropped on puzzle canvas (with tolerance)
                const puzzleRect = this.puzzleCanvas.getBoundingClientRect();
                const tolerance = 30; // Generous drop zone
                
                if (clientX >= puzzleRect.left - tolerance && clientX <= puzzleRect.right + tolerance &&
                    clientY >= puzzleRect.top - tolerance && clientY <= puzzleRect.bottom + tolerance) {
                    
                    // Smart grid snapping - find nearest valid position
                    const x = Math.max(0, Math.min(clientX - puzzleRect.left, this.canvasSize));
                    const y = Math.max(0, Math.min(clientY - puzzleRect.top, this.canvasSize));
                    
                    // Precise grid positioning - only snap when clearly within a cell
                    let col = Math.floor(x / this.pieceWidth);
                    let row = Math.floor(y / this.pieceHeight);
                    
                    // Only proceed if we're clearly within the cell boundaries (not on edges)
                    const cellX = x % this.pieceWidth;
                    const cellY = y % this.pieceHeight;
                    const margin = 3; // 3px margin from edges - less strict
                    
                    if (cellX < margin || cellX > this.pieceWidth - margin ||
                        cellY < margin || cellY > this.pieceHeight - margin) {
                        // Too close to edge - don't snap
                        this.snapBackToOriginal();
                        return;
                    }
                    
                    // Ensure within grid bounds
                    col = Math.max(0, Math.min(col, this.gridSize - 1));
                    row = Math.max(0, Math.min(row, this.gridSize - 1));
                    
                    // Check what's at this position
                    const occupiedPiece = this.pieces.find(p => 
                        p.placed && p.currentRow === row && p.currentCol === col && p !== this.draggedPiece);
                    
                    if (!occupiedPiece) {
                        // Position is free - place piece immediately
                        console.log(`Position (${row}, ${col}) is free, placing piece ${this.draggedPiece.id}`);
                        this.placePieceImmediately(this.draggedPiece, row, col);
                    } else {
                        // Position occupied - swap the pieces
                        console.log(`Position (${row}, ${col}) occupied by piece ${occupiedPiece.id}, swapping with piece ${this.draggedPiece.id}`);
                        this.swapPiecesImmediately(this.draggedPiece, occupiedPiece, row, col);
                    }
                } else {
                    // Dropped outside puzzle area
                    if (this.dragSource === 'puzzle') {
                        // Piece came from puzzle grid - move it back to pieces area
                        console.log('Moving piece from puzzle grid back to pieces area');
                        this.movePieceBackToPiecesArea(this.draggedPiece);
                    } else {
                        // Piece came from pieces area - snap back to original position
                        console.log('Dropped outside puzzle area, snapping back');
                        this.snapBackToOriginal();
                    }
                    return;
                }
            }
            
            movePieceBackToPiecesArea(piece) {
                console.log(`Moving piece ${piece.id} back to pieces area`);
                
                // Find an available position in the pieces area
                const availablePosition = this.findAvailablePositionInPiecesArea();
                
                // Remove from puzzle grid
                piece.placed = false;
                piece.currentRow = -1;
                piece.currentCol = -1;
                
                // Ensure exact grid positioning
                const snappedPos = this.snapToGridXY(availablePosition.x, availablePosition.y);
                piece.x = snappedPos.x;
                piece.y = snappedPos.y;
                
                // Force immediate re-render
                this.staticContentDirty = true;
                this.forceRender();
                
                this.updateDisplay();
                this.saveToStorage();
                
                console.log(`✅ Piece ${piece.id} moved back to pieces area at (${piece.x}, ${piece.y})`);
            }
            
            snapToGrid(coordinate, isY = false) {
                // Snap coordinate to nearest grid boundary
                const gridStep = isY ? this.pieceHeight : this.pieceWidth;
                return Math.round(coordinate / gridStep) * gridStep;
            }
            
            snapToGridXY(x, y) {
                return {
                    x: this.snapToGrid(x, false),
                    y: this.snapToGrid(y, true)
                };
            }
            
            findAvailablePositionInPiecesArea() {
                console.log(`Finding available position - pieceWidth: ${this.pieceWidth}, pieceHeight: ${this.pieceHeight}`);
                
                // Create a grid of all possible positions in pieces area
                const allPositions = [];
                for (let row = 0; row < this.gridSize; row++) {
                    for (let col = 0; col < this.gridSize; col++) {
                        const x = col * this.pieceWidth;
                        const y = row * this.pieceHeight;
                        allPositions.push({ x, y, row, col });
                    }
                }
                
                // Find positions that are not occupied by unplaced pieces
                const unplacedPieces = this.pieces.filter(p => !p.placed);
                console.log(`Unplaced pieces positions:`, unplacedPieces.map(p => `Piece ${p.id}: (${p.x}, ${p.y})`));
                
                // Check each position to see if it's occupied
                for (const pos of allPositions) {
                    const isOccupied = unplacedPieces.some(piece => 
                        Math.abs(piece.x - pos.x) < 1 && Math.abs(piece.y - pos.y) < 1
                    );
                    
                    if (!isOccupied) {
                        console.log(`Found available position at (${pos.x}, ${pos.y}) - grid (${pos.row}, ${pos.col})`);
                        return pos;
                    }
                }
                
                // If all positions are occupied, place at (0,0) - pieces can overlap
                console.log('All positions occupied, placing at (0,0)');
                return { x: 0, y: 0 };
            }
            
            placePieceImmediately(piece, row, col) {
                console.log(`Immediately placing piece ${piece.id} at row ${row}, col ${col}`);
                console.log(`Piece ${piece.id} correct position: row ${piece.correctRow}, col ${piece.correctCol}`);
                
                piece.placed = true;
                piece.currentRow = row;
                piece.currentCol = col;
                
                // Check if correct placement and update move counts
                this.moveCount++;
                console.log(`Total moves: ${this.moveCount}`);
                
                if (row === piece.correctRow && col === piece.correctCol) {
                    this.correctMoves++;
                    console.log(`✅ Correct placement! Piece ${piece.id} in right spot (${this.correctMoves}/${this.moveCount} correct)`);
                } else {
                    console.log(`❌ Incorrect placement! Piece ${piece.id} should be at (${piece.correctRow}, ${piece.correctCol}) but placed at (${row}, ${col})`);
                }
                
                // Mark static content as dirty and force immediate re-render
                this.staticContentDirty = true;
                this.forceRender();
                
                this.updateDisplay();
                this.checkWin();
                this.saveToStorage();
                
                console.log(`Piece ${piece.id} successfully placed immediately`);
            }
            
            placePieceAt(piece, row, col) {
                console.log(`Placing piece ${piece.id} at row ${row}, col ${col}`);
                
                piece.placed = true;
                piece.currentRow = row;
                piece.currentCol = col;
                
                // Check if correct placement
                if (row === piece.correctRow && col === piece.correctCol) {
                    this.correctMoves++;
                    console.log(`Correct placement! Piece ${piece.id} in right spot`);
                }
                
                // Mark static content as dirty and force immediate re-render
                this.staticContentDirty = true;
                this.render();
                
                // Smooth animation to final position
                this.animateToPosition(piece, col * this.pieceWidth, row * this.pieceHeight);
                
                this.updateDisplay();
                this.checkWin();
                this.saveToStorage();
            }
            
            swapPiecesImmediately(draggedPiece, occupiedPiece, newRow, newCol) {
                console.log(`Swapping pieces: ${draggedPiece.id} -> (${newRow}, ${newCol}), ${occupiedPiece.id} -> original position`);
                
                // Store occupied piece's current position
                const occupiedRow = occupiedPiece.currentRow;
                const occupiedCol = occupiedPiece.currentCol;
                
                // Move occupied piece to dragged piece's original position
                if (this.originalPosition && this.originalPosition.placed) {
                    // Swap within puzzle grid
                    occupiedPiece.currentRow = this.originalPosition.currentRow;
                    occupiedPiece.currentCol = this.originalPosition.currentCol;
                    occupiedPiece.placed = true;
                    console.log(`Occupied piece ${occupiedPiece.id} moved to grid position (${this.originalPosition.currentRow}, ${this.originalPosition.currentCol})`);
                } else {
                    // Move occupied piece back to pieces area
                    occupiedPiece.placed = false;
                    occupiedPiece.currentRow = -1;
                    occupiedPiece.currentCol = -1;
                    occupiedPiece.x = this.originalPosition ? this.originalPosition.x : 0;
                    occupiedPiece.y = this.originalPosition ? this.originalPosition.y : 0;
                    console.log(`Occupied piece ${occupiedPiece.id} moved back to pieces area at (${occupiedPiece.x}, ${occupiedPiece.y})`);
                }
                
                // Place dragged piece in new position immediately
                // Note: placePieceImmediately will handle move count increment
                this.placePieceImmediately(draggedPiece, newRow, newCol);
                
                // Update display and save
                this.updateDisplay();
                this.saveToStorage();
                
                console.log(`✅ Piece swap completed successfully`);
            }
            
            swapPieces(draggedPiece, occupiedPiece, newRow, newCol) {
                // Store occupied piece's position
                const occupiedRow = occupiedPiece.currentRow;
                const occupiedCol = occupiedPiece.currentCol;
                
                // Move occupied piece to dragged piece's original position
                if (this.originalPosition && this.originalPosition.placed) {
                    // Move to original grid position
                    occupiedPiece.currentRow = this.originalPosition.currentRow;
                    occupiedPiece.currentCol = this.originalPosition.currentCol;
                    occupiedPiece.placed = true;
                } else {
                    // Move back to pieces area
                    occupiedPiece.placed = false;
                    occupiedPiece.currentRow = -1;
                    occupiedPiece.currentCol = -1;
                    occupiedPiece.x = this.originalPosition ? this.originalPosition.x : 0;
                    occupiedPiece.y = this.originalPosition ? this.originalPosition.y : 0;
                }
                
                // Place dragged piece in new position
                this.placePieceAt(draggedPiece, newRow, newCol);
            }
            
            animateToPosition(piece, targetX, targetY) {
                const startX = piece.x || targetX;
                const startY = piece.y || targetY;
                const duration = 200;
                const startTime = Date.now();
                
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easeOut = 1 - Math.pow(1 - progress, 3);
                    
                    if (piece.placed) {
                        // For placed pieces, we don't need to animate x,y (they're positioned by grid)
                        piece.x = targetX;
                        piece.y = targetY;
                    } else {
                        piece.x = startX + (targetX - startX) * easeOut;
                        piece.y = startY + (targetY - startY) * easeOut;
                    }
                    
                    this.render();
                    
                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    }
                };
                
                requestAnimationFrame(animate);
            }
            
            checkWin() {
                const allPlaced = this.pieces.every(piece => piece.placed);
                const allCorrect = this.pieces.every(piece => 
                    piece.currentRow === piece.correctRow && 
                    piece.currentCol === piece.correctCol);
                
                if (allPlaced && allCorrect && !this.gameCompleted) {
                    this.gameCompleted = true;
                    this.endTime = Date.now();
                    this.stopTimer();
                    this.updateDisplay();
                    this.showCompletionModal();
                    this.saveToStorage();
                }
            }
            
            showCompletionModal() {
                const totalTime = this.endTime - this.startTime;
                const hours = Math.floor(totalTime / (1000 * 60 * 60));
                const minutes = Math.floor((totalTime % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((totalTime % (1000 * 60)) / 1000);
                
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                document.getElementById('finalTime').textContent = timeString;
                
                // Generate results code
                const resultsCode = this.generateResultsCode(totalTime);
                document.getElementById('resultsCode').textContent = resultsCode;
                
                document.getElementById('completionModal').style.display = 'flex';
            }
            
            generateResultsCode(totalTime) {
                const accuracy = this.moveCount > 0 ? Math.round((this.correctMoves / this.moveCount) * 100) : 0;
                const difficulty = this.gridSize;
                const timeInSeconds = Math.floor(totalTime / 1000);
                const completedDate = new Date().toISOString();
                
                // Format each metric on its own line for better readability
                return `🏆 COMPETITION RESULTS 🏆
Session ID: ${this.sessionId}
Completion Time: ${timeInSeconds} seconds
Grid Size: ${difficulty}x${difficulty}
Total Moves: ${this.moveCount}
Accuracy: ${accuracy}%
Completed: ${completedDate.split('T')[0]} at ${completedDate.split('T')[1].split('.')[0]}

🎯 Result Code: PUZZLE-${this.sessionId}-${timeInSeconds}s-${accuracy}%`;
            }
            
            resetGame() {
                this.gameStarted = false;
                this.gameCompleted = false;
                this.startTime = null;
                this.endTime = null;
                this.moveCount = 0;
                this.correctMoves = 0;
                this.stopTimer();
                document.getElementById('timer').textContent = '00:00:00';
            }
            
            forceNewPuzzle() {
                console.log('🔄 Forcing new puzzle - clearing localStorage');
                localStorage.removeItem('puzzleGameState');
                this.gridSize = 8;
                console.log('✅ Grid size reset to:', this.gridSize);
                this.loadDefaultImage();
            }
            
            captureScreenshot() {
                const canvas = document.createElement('canvas');
                canvas.width = 800;
                canvas.height = 500;
                const ctx = canvas.getContext('2d');
                
                // White background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, 800, 500);
                
                // Draw completed puzzle
                ctx.drawImage(this.puzzleCanvas, 50, 50);
                
                // Add completion info
                ctx.fillStyle = '#333';
                ctx.font = 'bold 24px Arial';
                ctx.fillText('Puzzle Completed!', 500, 100);
                
                ctx.font = '18px Arial';
                const totalTime = this.endTime - this.startTime;
                const hours = Math.floor(totalTime / (1000 * 60 * 60));
                const minutes = Math.floor((totalTime % (1000 * 60 * 60)) / (1000 * 60));
                const seconds = Math.floor((totalTime % (1000 * 60)) / 1000);
                const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                
                ctx.fillText(`Time: ${timeString}`, 500, 140);
                ctx.fillText(`Difficulty: ${this.gridSize}x${this.gridSize}`, 500, 170);
                ctx.fillText(`Session: ${this.sessionId}`, 500, 200);
                ctx.fillText(`Accuracy: ${Math.round((this.correctMoves / this.moveCount) * 100)}%`, 500, 230);
                
                return canvas.toDataURL('image/png');
            }
        }
        
        // Global puzzle instance
        let puzzle;
        
        function init() {
            puzzle = new CompetitionJigsawPuzzle();
        }
        
        function loadImageFile(file) {
            if (puzzle && file) {
                puzzle.loadImage(file);
            }
        }
        
        function useDefaultImage() {
            if (puzzle) {
                // Clear any existing game state to force loading fresh
                puzzle.resetGame();
                puzzle.loadDefaultImage();
            }
        }
        
        function resetPuzzle() {
            if (puzzle) {
                // Store current timer state
                const wasStarted = puzzle.gameStarted;
                const currentStartTime = puzzle.startTime;
                const currentTimerInterval = puzzle.timerInterval;
                
                puzzle.shufflePieces();
                
                // Reset only non-timer game state
                puzzle.gameCompleted = false;
                puzzle.endTime = null;
                puzzle.moveCount = 0;
                puzzle.correctMoves = 0;
                
                // Restore timer state if game was already started
                if (wasStarted && currentStartTime) {
                    puzzle.gameStarted = true;
                    puzzle.startTime = currentStartTime;
                    puzzle.timerInterval = currentTimerInterval;
                } else {
                    puzzle.gameStarted = false;
                    puzzle.startTime = null;
                    if (puzzle.timerInterval) {
                        clearInterval(puzzle.timerInterval);
                        puzzle.timerInterval = null;
                    }
                    document.getElementById('timer').textContent = '00:00:00';
                }
                
                puzzle.updateDisplay();
            }
        }
        
        function clearProgress() {
            if (confirm('Are you sure you want to clear all progress? This cannot be undone.')) {
                localStorage.removeItem('puzzleGameState');
                if (puzzle) {
                    puzzle.loadDefaultImage();
                }
            }
        }
        
        function autoSolve() {
            if (!puzzle) return;
            
            console.log('🧩 Auto-solving puzzle for testing...');
            
            // Start the game if not started
            if (!puzzle.gameStarted) {
                puzzle.gameStarted = true;
                puzzle.startTime = Date.now();
                puzzle.startTimer();
            }
            
            // Place all pieces in their correct positions
            puzzle.pieces.forEach(piece => {
                piece.placed = true;
                piece.currentRow = piece.correctRow;
                piece.currentCol = piece.correctCol;
                piece.x = piece.correctCol * puzzle.pieceWidth;
                piece.y = piece.correctRow * puzzle.pieceHeight;
            });
            
            // Update move count to simulate some moves
            puzzle.moveCount = puzzle.pieces.length;
            puzzle.correctMoves = puzzle.pieces.length; // All moves were "correct"
            
            // Trigger completion
            puzzle.render();
            puzzle.updateDisplay();
            puzzle.checkWin();
            
            console.log('✅ Puzzle auto-solved! Completion modal should appear.');
        }
        
        function closeModal() {
            document.getElementById('completionModal').style.display = 'none';
        }
        
        function submitQuizAnswers() {
            // TODO: Replace with actual quiz submission URL
            const quizUrl = 'https://example.com/quiz-submission'; // PLACEHOLDER - Replace with actual URL
            
            // Open quiz submission page in new window/tab
            window.open(quizUrl, '_blank');
            
            // Optionally close the modal after opening the quiz
            closeModal();
        }
        
        function copyResults() {
            const resultsCode = document.getElementById('resultsCode').textContent;
            navigator.clipboard.writeText(resultsCode).then(() => {
                alert('Results copied to clipboard!');
            }).catch(() => {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = resultsCode;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('Results copied to clipboard!');
            });
        }
        
        function downloadScreenshot() {
            const screenshot = puzzle.captureScreenshot();
            const link = document.createElement('a');
            link.download = `puzzle-completion-${puzzle.sessionId}.png`;
            link.href = screenshot;
            link.click();
        }
        
        function shareResults() {
            const resultsCode = document.getElementById('resultsCode').textContent;
            const text = `I just completed a jigsaw puzzle! 🧩\n\nResults: ${resultsCode}\n\nTry it yourself!`;
            
            if (navigator.share) {
                navigator.share({
                    title: 'Puzzle Completion',
                    text: text,
                    url: window.location.href
                });
            } else {
                copyResults();
                alert('Results copied! You can now paste and share them.');
            }
        }
        
        function saveScore() {
            const userName = document.getElementById('userName').value.trim();
            const userEmail = document.getElementById('userEmail').value.trim();
            
            if (!userName || !userEmail) {
                alert('Please enter both your name and email address.');
                return;
            }
            
            // Validate email format
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!emailRegex.test(userEmail)) {
                alert('Please enter a valid email address.');
                return;
            }
            
            // Create score entry
            const scoreEntry = {
                sessionId: puzzle.sessionId,
                name: userName,
                email: userEmail,
                completionTime: puzzle.endTime - puzzle.startTime,
                timeString: document.getElementById('finalTime').textContent,
                difficulty: puzzle.gridSize,
                moveCount: puzzle.moveCount,
                accuracy: Math.round((puzzle.correctMoves / puzzle.moveCount) * 100),
                completedAt: new Date().toISOString(),
                resultsCode: puzzle.generateResultsCode(puzzle.endTime - puzzle.startTime)
            };
            
            // Save to localStorage database
            saveToDatabase(scoreEntry);
            
            // Show success message and proceed to results
            alert(`Score saved successfully! Thank you ${userName}!`);
            showResultsSection();
        }
        
        function skipSaving() {
            showResultsSection();
        }
        
        function showResultsSection() {
            document.getElementById('userInfoForm').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'block';
        }
        
        function saveToDatabase(scoreEntry) {
            // Show loading state
            const saveBtn = document.getElementById('saveScoreBtn');
            const originalText = saveBtn.textContent;
            saveBtn.textContent = '💾 Saving...';
            saveBtn.disabled = true;
            
            // Send to server database
            fetch('/api/scores', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(scoreEntry)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return response.json();
            })
            .then(data => {
                console.log('Score saved to database:', data);
                
                // Also save to localStorage as backup
                let localScores = [];
                const existingScores = localStorage.getItem('puzzleScores');
                if (existingScores) {
                    try {
                        localScores = JSON.parse(existingScores);
                    } catch (e) {
                        localScores = [];
                    }
                }
                localScores.push(scoreEntry);
                localStorage.setItem('puzzleScores', JSON.stringify(localScores));
                
                // Show success and proceed
                alert(`Score saved successfully! Thank you ${scoreEntry.name}!`);
                showResultsSection();
            })
            .catch(error => {
                console.error('Error saving to database:', error);
                
                // Fallback to localStorage if server fails
                let localScores = [];
                const existingScores = localStorage.getItem('puzzleScores');
                if (existingScores) {
                    try {
                        localScores = JSON.parse(existingScores);
                    } catch (e) {
                        localScores = [];
                    }
                }
                localScores.push(scoreEntry);
                localStorage.setItem('puzzleScores', JSON.stringify(localScores));
                
                alert(`Score saved locally! (Server unavailable - will sync when server is available)\nThank you ${scoreEntry.name}!`);
                showResultsSection();
            })
            .finally(() => {
                // Restore button state
                saveBtn.textContent = originalText;
                saveBtn.disabled = false;
            });
        }
        
        function getLeaderboard(limit = 10, difficulty = null) {
            return fetch(`/api/leaderboard?limit=${limit}${difficulty ? `&difficulty=${difficulty}` : ''}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error('Error fetching leaderboard:', error);
                    // Fallback to localStorage
                    const scores = localStorage.getItem('puzzleScores');
                    if (scores) {
                        try {
                            return JSON.parse(scores).slice(0, limit);
                        } catch (e) {
                            return [];
                        }
                    }
                    return [];
                });
        }
        
        function exportDatabase() {
            fetch('/api/scores/export')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    const dataStr = JSON.stringify(data, null, 2);
                    const dataBlob = new Blob([dataStr], {type: 'application/json'});
                    
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(dataBlob);
                    link.download = `puzzle-scores-export-${new Date().toISOString().split('T')[0]}.json`;
                    link.click();
                })
                .catch(error => {
                    console.error('Error exporting from database:', error);
                    // Fallback to localStorage export
                    const scores = localStorage.getItem('puzzleScores');
                    if (scores) {
                        const dataStr = JSON.stringify({
                            total: JSON.parse(scores).length,
                            exported_at: new Date().toISOString(),
                            source: 'localStorage_fallback',
                            scores: JSON.parse(scores)
                        }, null, 2);
                        const dataBlob = new Blob([dataStr], {type: 'application/json'});
                        
                        const link = document.createElement('a');
                        link.href = URL.createObjectURL(dataBlob);
                        link.download = `puzzle-scores-local-${new Date().toISOString().split('T')[0]}.json`;
                        link.click();
                    } else {
                        alert('No scores available to export');
                    }
                });
        }
        
        function getStats() {
            return fetch('/api/stats')
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                })
                .catch(error => {
                    console.error('Error fetching stats:', error);
                    return null;
                });
        }
        
        // Timer pause/resume on window visibility change
        document.addEventListener('visibilitychange', function() {
            if (!puzzle) return;
            
            if (document.hidden) {
                // Page is hidden (user switched tabs, minimized window, etc.)
                if (puzzle.gameStarted && !puzzle.gameCompleted && puzzle.timerInterval) {
                    puzzle.stopTimer();
                    puzzle.timerPaused = true;
                    console.log('Timer paused - page hidden');
                }
            } else {
                // Page is visible again
                if (puzzle.gameStarted && !puzzle.gameCompleted && puzzle.timerPaused) {
                    puzzle.startTimer();
                    puzzle.timerPaused = false;
                    console.log('Timer resumed - page visible');
                }
            }
        });
        
        // Handle page unload (closing tab/window)
        window.addEventListener('beforeunload', function() {
            if (puzzle && puzzle.gameStarted && !puzzle.gameCompleted) {
                puzzle.stopTimer();
                console.log('Timer stopped - page unloading');
            }
        });
        
        // Start the game when page loads
        window.addEventListener('load', init);
    </script>
    
    <!-- Footer -->
    <footer class="footer">
        <div class="footer-content">
            <!-- Contact Information -->
            <div class="footer-section">
                <h3>Contact Us</h3>
                <div class="footer-contact">
                    <p><strong>Phone:</strong> 01252 929319</p>
                    <p><strong>Email:</strong> info@tratechconsulting.co.uk</p>
                    <p><strong>Address:</strong><br>
                    Abbey House, 282 Farnborough Rd<br>
                    Farnborough, GU14 7NA</p>
                </div>
            </div>
            
            <!-- Accreditations -->
            <div class="footer-section">
                <h3>Accreditations & Partners</h3>
                <div class="footer-accreditations">
                    <img src="ISOQAR-joint-logo-all-white.webp" alt="ISOQAR Certification" class="accreditation-logo">
                    <img src="farnborough (1).jpg" alt="Farnborough FC" class="accreditation-logo">
                </div>
            </div>
            
            <!-- Legal & Navigation -->
            <div class="footer-section">
                <h3>Legal & Information</h3>
                <ul>
                    <li><a href="#" onclick="return false;">Terms and Conditions</a></li>
                    <li><a href="#" onclick="return false;">Privacy Policy</a></li>
                    <li><a href="#" onclick="return false;">Cookie Policy</a></li>
                    <li><a href="#" onclick="return false;">Modern Slavery Policy</a></li>
                    <li><a href="#" onclick="return false;">Sitemap</a></li>
                    <li><a href="#" onclick="return false;">Areas We Cover</a></li>
                </ul>
            </div>
            
        </div>
    </footer>
</body>
</html>
